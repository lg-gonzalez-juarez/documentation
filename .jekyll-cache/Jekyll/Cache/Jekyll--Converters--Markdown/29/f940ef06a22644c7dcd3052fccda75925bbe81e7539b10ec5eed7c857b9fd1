I"⁄<h2 id="understanding-immutability">Understanding Immutability</h2>

<p>As we start digging into sequence types like strings, lists, tuples, and dictionaries, we need to start thinking about the mutability of a type or whether or not it can change. Normally, we‚Äôll talk about whether or not a type is ‚Äúimmutable,‚Äù meaning that it can‚Äôt be changed, and most of the types we‚Äôve looked at thus far are immutable.</p>

<h3 id="documentation-for-this-video">Documentation For This Video</h3>

<p><a href="https://docs.python.org/3/library/stdtypes.html#immutable-sequence-types">Immutable Sequences</a></p>

<h3 id="why-does-immutability-matter">Why Does Immutability Matter?</h3>

<p>Immutability is something that we don‚Äôt always have to think about, but it does matter in a few very common cases:</p>

<h3 id="understanding-why-we-cant-modify-a-string-in-place">Understanding why we can‚Äôt modify a string in-place</h3>

<p>Using objects as keys for dictionaries (we‚Äôll get to this later)
We‚Äôll cover dictionaries in a different section, but when it comes to strings, wanting to modify a string variable is fairly common. Strings are an immutable type in Python, so we can‚Äôt change a string object. We can only create new strings with the modifications that we wanted. This means that the only way for us to change the string value of a variable is to explicitly reassign it. As we learn about mutable types, we‚Äôll see that other types allow us to modify the value of a variable without explicitly reassigning it.</p>

<h3 id="immutability-of-strings">Immutability of Strings</h3>

<p>When looking at str class there are many methods that return a str to us, such as capitalize:</p>

<pre><code class="language-cmd">&gt;&gt;&gt; my_str = 'testing'
&gt;&gt;&gt; my_str.capitalize()
'Testing'
&gt;&gt;&gt; my_str
'testing'
</code></pre>
<p>We won‚Äôt find a method that changes the value of my_str in this example. Beyond this, each unique string that we can only type will only exist once in memory. In our case, we referenced the literal ‚Äòtesting‚Äô when we assigned the value to our variable, and if we ever use the literal of ‚Äòtesting‚Äô again it will point to the same point in memory, because that value can‚Äôt be modified.</p>

<pre><code class="language-cmd">&gt;&gt;&gt; id(my_str)
4522355248
&gt;&gt;&gt; id('testing')
4522355248
</code></pre>
<p>This feature prevents the same value being allocated more than once and taking up more spots in our computer‚Äôs memory than we need it to.</p>

<h2 id="the-len-function">The <code class="language-plaintext highlighter-rouge">len</code> Function</h2>

<p>In this short lesson, we‚Äôre going to take a look at a built-in function that will help us see how long any sequence or collection type is, including strings: the len function.</p>

<h3 id="documentation-for-this-video-1">Documentation For This Video</h3>

<p><a href="https://docs.python.org/3/library/functions.html#len">The len function</a></p>

<h3 id="the-len-function-1">The len Function</h3>
<p>Needing to know the length of a string is very common. Thankfully, the len function will return how many characters are in a string:</p>

<pre><code class="language-cmd">&gt;&gt;&gt; len('testing')
7
&gt;&gt;&gt; len('')
0
</code></pre>

<p>This may seem a little boring, but it will help us to keep from causing too many errors when we start learning about indexing and slicing in the next lesson.</p>

<h2 id="string-indexing-and-slicing">String Indexing and Slicing</h2>

<p>Sometimes we need to access a specific item, or a subset of items, in a sequence. To do that in Python, we‚Äôll use indexing and slicing.</p>

<h3 id="documentation-for-this-video-2">Documentation For This Video</h3>

<p><a href="https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str">Text Sequence Type str</a></p>

<h3 id="indexing">Indexing</h3>

<p>When we need to access a single item from a sequence, like a string, we‚Äôll use ‚Äúindexing.‚Äù Every item in a sequence type has an index that indicates the item‚Äôs position in the sequence. The first item in a Python sequence has the index of 0, and each subsequent item‚Äôs index increases by one. To perform indexing, we‚Äôll use square brackets ([ and ]) on the right-hand side of our string (or string variable), and within the square brackets we‚Äôll put the index number that we‚Äôd like to access:</p>

<pre><code class="language-cmd">&gt;&gt;&gt; test_str = 'testing'
&gt;&gt;&gt; test_str[0]
't'
</code></pre>
<p>There isn‚Äôt a character type in Python, so the return value will be a length one string. When indexing a string, the index must exist, otherwise, Python will raise an error:</p>

<pre><code class="language-cmd">&gt;&gt;&gt; test_str[10]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
IndexError: string index out of range
</code></pre>

<p>This is one of the areas where using len can help us avoid using an index that is too high. But since the starting index is 0, then the final index will always be len(test_str) - 1:</p>

<pre><code class="language-cmd">&gt;&gt;&gt; test_str[len(test_str) - 1]
'g'
</code></pre>

<p>If we try to use a negative index, it will actually start giving us items relative to the end of the string:</p>

<pre><code class="language-cmd">&gt;&gt;&gt; test_str[-1]
'g'
&gt;&gt;&gt; test_str[-4]
't'
&gt;&gt;&gt; test_str[-8]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
IndexError: string index out of range
</code></pre>

<h3 id="slicing">Slicing</h3>

<p>If we want to get a subsection of our string then we‚Äôll do what is called slicing. Slicing allows us to specify the index of the first element that we would like, followed by the index just beyond the last item that we‚Äôd like. We separate these indexes by using a colon (:)</p>

<pre><code class="language-cmd">&gt;&gt;&gt; test_str[0:2]
'te'
&gt;&gt;&gt; test_str[3:5]
'ti'
</code></pre>

<p>If we‚Äôd like to get all of the items after our starting index then we can use the length of the string as our second index, even though it‚Äôs technically out of range. Or we can simply put nothing after the colon:</p>

<pre><code class="language-cmd">&gt;&gt;&gt; test_str[2:len(test_str)]
'sting'
&gt;&gt;&gt; test_str[2:]
'sting'
</code></pre>

<p>The last thing to mention about slicing is that there is a third number that we can use: the ‚Äústep‚Äù value. By default, this value is 1 and just means that we‚Äôll go one-by-one through the sequence. But we can change this to grab every other item if we‚Äôd like by adding a second colon and the step size that we‚Äôd like to use:</p>

<pre><code class="language-cmd">&gt;&gt;&gt; test_str
'testing'
&gt;&gt;&gt; test_str[1:5:2]
'et'
&gt;&gt;&gt; test_str[1::2]
'etn'
</code></pre>

<p>One neat thing that we can do with this step option is stepping backward by using a negative step value. We can reverse an entire string by leaving off the start and end indexes and setting the step value to -1:</p>

<pre><code class="language-cmd">&gt;&gt;&gt; test_str[::-1]
'gnitset'
</code></pre>

<p>[]:</p>

:ET