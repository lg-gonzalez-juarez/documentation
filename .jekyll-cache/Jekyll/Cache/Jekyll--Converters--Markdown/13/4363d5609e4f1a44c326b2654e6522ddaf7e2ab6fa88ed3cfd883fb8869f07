I"!%<h2 id="451-interacting-with-files">45.1. Interacting with Files</h2>

<p>There are some core actions that we need to understand how to do in any programming language, in order to be very productive. One of these actions is interacting with files. In this lesson, we’ll learn how to read from and write to files, and we’ll take a look at how bytes can be represented in code.</p>

<h3 id="documentation">Documentation</h3>

<ul>
  <li><a href="https://docs.python.org/3/library/functions.html#open">The open function</a></li>
  <li><a href="https://docs.python.org/3/glossary.html#term-file-object">The file object</a></li>
  <li><a href="https://docs.python.org/3/library/io.html#io-overview">The io module</a></li>
  <li><a href="https://docs.python.org/3.7/library/stdtypes.html#bytes-objects">Bytes Objects</a></li>
</ul>

<h3 id="files-as-objects">Files as Objects</h3>

<p>One of the beautiful aspects of working in an object-oriented programming language is that we can represent concepts as objects with functionality. Files are a great use case for this. Python gives us the <a href="https://docs.python.org/3/glossary.html#term-file-object">file object</a> (or concept, really). These objects provide us a few things:</p>

<ul>
  <li>A <code class="language-plaintext highlighter-rouge">read</code> method to access the underlying data in the file</li>
  <li>A <code class="language-plaintext highlighter-rouge">write</code> method to place data into the underlying file</li>
</ul>

<p>To test this out, we’re going to create a simple text file with some names it in, and then read and modify it to see what we can learn.</p>

<h3 id="opening-a-file">Opening a File</h3>

<p>The first step to interacting with a file is to “open” it, and in Python, we’ll use the <a href="https://docs.python.org/3/library/functions.html#open">open function</a>. This function takes two main arguments:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">file</code> - The path to the file on disk (or where you’d like to create it)</li>
  <li><code class="language-plaintext highlighter-rouge">mode</code> - How you would like to interact with the file</li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">file</code> argument is pretty simple, but the <code class="language-plaintext highlighter-rouge">mode</code> argument has a variety of options that all work a little differently:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">'r'</code> - Opens the file for reading, which is the default mode</li>
  <li><code class="language-plaintext highlighter-rouge">'w'</code> - Opens the file for writing, while removing the existing content (truncating the file)</li>
  <li><code class="language-plaintext highlighter-rouge">'x'</code> - Opens the file to create it, failing if the file already exists</li>
  <li><code class="language-plaintext highlighter-rouge">'a'</code> - Opens the file for writing without truncating, appending any new writes to the end of the file</li>
  <li><code class="language-plaintext highlighter-rouge">'b'</code> - Opens the file in binary mode, in which the file expects to write and return bytes objects</li>
  <li><code class="language-plaintext highlighter-rouge">'t'</code> - Opens the file in text mode, the default mode, where the object expects to write and return strings</li>
  <li><code class="language-plaintext highlighter-rouge">'+'</code> - Opens the file for reading and writing</li>
</ul>

<p>These modes can be used in combination, so <code class="language-plaintext highlighter-rouge">w+b</code> is a valid mode saying that we want to read and write with bytes, and with the existing file being truncated (from the w).</p>

<p>Let’s create a new script called <code class="language-plaintext highlighter-rouge">using_files.py</code> (within a new directory called <code class="language-plaintext highlighter-rouge">file_io</code>), and we’ll start interacting with a file containing some names. The file doesn’t exist yet, but if it did, we’d like to truncate it and prepare to write to it.</p>

<p><code class="language-plaintext highlighter-rouge">~/file_io/using_files.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>my_file = open('xmen.txt', 'w+')
</code></pre></div></div>

<p>Now we have a new file object that we can write to.</p>

<h3 id="writing-to-the-file">Writing to the File</h3>

<p>Before we can read from our file, we need it to have some content. There are a few primary methods that we’ll interact with depending on whether or not we want to work with lines or individual characters. The write method only writes the characters that we specify, where the writelines method takes a list of strings that should all be on their own line. Let’s add some names to our file, each on its own line, using both methods:</p>

<p><code class="language-plaintext highlighter-rouge">~/file_io/using_files.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>my_file = open('xmen.txt', 'w+')
my_file.write('Beast\n')
my_file.write('Phoenix\n')
my_file.writelines([
    'Cyclops',
    'Bishop',
    'Nightcrawler',
])
</code></pre></div></div>

<p>Let’s save the file, run it, and then check the contents of <code class="language-plaintext highlighter-rouge">xmen.txt</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3.7 using_files.py
$ cat xmen.txt
Beast
Phoenix
CyclopsBishopNightcrawler
$
</code></pre></div></div>

<p>This isn’t quite what we expected. You would probably think that writelines would add a new line with each entry, but we still need to add the ‘\n’ to the end of each item. The writelines method is more of a shorthand for multiple calls to write, however you can use newline=’\n’ when we opened the file.</p>

<p>Another thing that we didn’t do is close the file. When we’re finished working with a file, we should call the close method. It’s not necessary when running this script because the filehandle will be closed when the program terminates. But when we’re interacting with files, from within a server, for instance, the program won’t terminate for a long time.</p>

<h3 id="reading-from-a-file">Reading from a File</h3>

<p>Now that we have some content in the file, let’s close it within the script and then re-open it for reading.</p>

<p>~/file_io/using_files.py</p>

<p>my_file = open(‘xmen.txt’, ‘w+’)
my_file.write(‘Beast\n’)
my_file.write(‘Phoenix\n’)
my_file.writelines([
    ‘Cyclops\n’,
    ‘Bishop\n’,
    ‘Nightcrawler\n’,
])
my_file.close()</p>

<p>my_file = open(‘xmen.txt’, ‘r’)
print(my_file.read())
my_file.close()
Now we can run the script again to see what happens:</p>

<p>$ python3.7 using_files.py
Beast
Phoenix
Cyclops
Bishop
Nightcrawler</p>

<p>$
Since we’re reading the file in ‘text’ mode, we’ll receive a single string from the read method that contains the newline characters, and when printed, it will print the newlines accordingly. If we didn’t want this parsing to occur, we could work with the file in bytes mode.</p>

<p>If we were to call the read method again, we would receive an empty string in response. This is because the file holds onto a cursor for the location within the file, and when we read, it returns everything after that cursor’s position, and moves the cursor to the end. To reread the existing content, we’ll need to use seek to move within in the file. Additionally, as an alternative to read we can use readlines to return a list of lines in the file (this can allow you to work with the data a little easier). Here’s an example of both of these things in action.</p>

<p>~/file_io/using_files.py</p>

<p>my_file.write(‘Beast\n’)
my_file.write(‘Phoenix\n’)
my_file.writelines([
    ‘Cyclops\n’,
    ‘Bishop\n’,
    ‘Nightcrawler\n’,
])</p>

<p>my_file.seek(0)
my_file.write(‘Morph’)
my_file.seek(0)
for line in my_file.readlines():
    print(line)</p>

<p>my_file.close()
This would output:</p>

<p>$ python3.7 using_files.py
Morph</p>

<p>Phoenix</p>

<p>Cyclops</p>

<p>Bishop</p>

<p>Nightcrawler</p>

<p>$
The with Statement
Remembering to close files that we opened can be tedious, and to get around this, Python gives us the with statement. A with statement takes an object that has a close method and will call that method after the block has run.</p>

<p>Let’s rewrite our existing code to utilize the with statement:</p>

<p>~/file_io/using_files.py</p>

<p>with open(‘xmen.txt’, ‘w+’) as my_file:
    my_file.write(‘Beast\n’)
    my_file.write(‘Phoenix\n’)
    my_file.writelines([
        ‘Cyclops\n’,
        ‘Bishop\n’,
        ‘Nightcrawler\n’,
    ])</p>

<p>my_file = open(‘xmen.txt’, ‘r’)
with my_file:
    print(my_file.read())
When we open the file to write, we’re using the shorthand as expression to open the file within the with statement, and assigning it to the variable my_file within the block. This is a really handy tool if we don’t need to use the file in any other way. An alternative would be to create the my_file variable manually and then pass the variable into the with statement like we did when we were reading from the file.</p>

<h2 id="452-working-with-bytes">45.2. Working with Bytes</h2>

<p>[]:</p>

:ET