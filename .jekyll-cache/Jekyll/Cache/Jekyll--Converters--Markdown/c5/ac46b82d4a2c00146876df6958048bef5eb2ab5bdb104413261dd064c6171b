I"wX<h3 id="print-screen">Print Screen</h3>
<pre><code class="language-cmd">fprint-sprintf
</code></pre>
<p><code></code></p>

<h2 id="setting-screen">Setting Screen</h2>
<pre><code class="language-cmd">set(0,'units','centimeters')
get(0,'MonitorPosition')
get(0,'ScreenSize')
fprintf(lineSec,'a','Nombre Bloques');
disp(blks); pause (2); 
</code></pre>

<h2 id="display-properties-of-simulink-blocks">Display properties of Simulink Blocks</h2>
<pre><code class="language-cmd"> for n=1:length(Tag_blck),  
    title=strcat(Tag_blck{n},'=&gt; ',num2str(blks_pos{n}));
    fprintf('%s \n',title);
end

Position==[left bottom width height]; 
sprintf('%c',char(245)); tic
</code></pre>

<pre><code class="language-cmd">U=1*exp(2*i*pi*50); 
    disp('U'); 
I=0.5*exp(-i*2*pi*50); 
    disp ('I')
S=U*conj(I); toc ; tic; 
    fprintf('%d \n',S); toc; tic; disp (S); toc
</code></pre>

<h2 id="no-imprime-variables">no imprime variables</h2>
<p>tic; sprintf(‘%d \n’,S) ;toc</p>

<h2 id="mejor-opcion-para-desplegar-lineas">Mejor opcion para desplegar lineas</h2>

<pre><code class="language-cmd">tic; fprintf('%c',char(frame01));
fprintf('\n'); 
sprintf('%c',char(frame01)),sprintf('\n');toc

### Adaptacion de pc/folder en matlab

```cmd
addpath('D:\MTLB\bin\MyComputePrg\Sags');&amp;#xD;
addpath('D:\MTLB\bin\MyComputePrg\sourceVabc');&amp;#xD;
addpath(genpath('D:\THESIS\CODE\Matlab\sysREE\rev1'))
</code></pre>

<h3 id="size-screen">SIZE SCREEN</h3>

<pre><code class="language-cmd">scrsz = get(0,'ScreenSize'); en pixeles
... tipo centimeter normalized
left=1; bottom=1; width=20;  height=10;&amp;#xD;
figure('units','centimeter','Position',[left, bottom, width, height]);

OTHERS
get(gcf,'Position');
set(gcf,'Units','centimeters');
</code></pre>

<h3 id="conocer-el-tamaño-de-cada-monitor">CONOCER EL TAMAÑO DE CADA MONITOR</h3>

<p>```cmd
get(0,’MonitorPosition’)&lt;/code&gt;<!-- --><!-- ================================ -->&lt;hr&gt;&lt;caption&gt;PRINTF &lt;/caption&gt;Para imprimir al tamaño deseado<code> set(gcf, 'PaperUnits', 'centimeters');&#xD;       width = 15;   height = 15;        set(gcf, 'PaperSize', [width height]);&#xD;       papersize = get(gcf, 'PaperSize');       left = (papersize(1)- width)/2;&#xD;       bottom = (papersize(2)- height)/2;       myfiguresize = [left, bottom, width, height];&#xD;       set(gcf, 'PaperPosition', myfiguresize);&#xD;... Para imprimir al tamaño deseado&#xD;set(gcf, 'PaperUnits', 'centimeters');&#xD;width = 15;   height = 15; &#xD;set(gcf, 'PaperSize', [width height]);&#xD;papersize = get(gcf, 'PaperSize');&#xD;left = (papersize(1)- width)/2;&#xD;bottom = (papersize(2)- height)/2;&#xD;myfiguresize = [left, bottom, width, height];&#xD;set(gcf, 'PaperPosition', myfiguresize);&#xD;&#xD;set(gcf,'Units','centimeters','Position',[4,14,15,10])&#xD;set(gcf, 'PaperUnits', 'centimeters','PaperSize',[15,10],...&#xD;'PaperPosition',[0,0,15,10]);&#xD;A4-21.59*27.94 </code>  <!-- -->&lt;hr&gt;&lt;caption&gt;PLOTS &lt;/caption&gt;<code> %print -dpdf Intensidad_sag_ang.pdf;  pause(1); clf; close;&#xD;    %winopen  'Intensidad_sag_ang.pdf'&#xD;    %print -depsc Intensidad_sag_ang.eps; % pause(1); clf; close;&#xD;    %winopen  'Intensidad_sag_ang.eps'&#xD;    %copyfile('Intensidad_sag_ang.eps',destine)&#xD;    pause(2); close all;</code><!-- -->  &lt;caption&gt; para ponerle nombre a una figura&lt;/caption&gt;figure(‘name’,’Ic-Vdip &lt;-&gt; Angulo de carga variando’); hold on%set(figH,’Name’,’something else’,’NumberTitle’,’off’)<!-- -->Esto es la mejor opcion en tiempo de computo<code>tic;disp(sprintf('%c',char(frame01)));toc</code> <!-- --><strong>datos de numero a letras</strong><code>num2str(SG1(1:3,1)</code>formato pdf: existen 2 formas a) usando un comando de linea, pero habria que darle el tamaño especifico b) imprimiendo en eps y pasandolo a pdf usando un archivo en ubuntu para esta conversion<strong>formato eps:</strong><code>print -deps NameFile</code><strong>Formato de impresion</strong><code>pdf o eps</code><!-- -->&lt;caption&gt;CONFIGURATION PLOTS:&lt;/caption&gt;<code>iLocLeg='EastOutside';&#xD;ColorLine=[0 0 0]; StyleLine='.-|--|-.|:';&#xD;&#xD;set(gcf,'DefaultLineLineWidth',1.5)&#xD;set(gcf,'DefaultAxesColorOrder',ColorLine,...&#xD;      'DefaultAxesLineStyleOrder',StyleLine)&#xD;&#xD;iFontSize=14; iLineWidth=2; jFontSize=15;&#xD;strFontName='Arial';&#xD;&#xD;set(gcf,'Defaultaxesfontsize',jFontSize,...&#xD;    'DefaultAxesFontName','strFontName',...&#xD;'DefaultAxesFontUnits','centimeters');&#xD;&#xD;%---PutNameAxes&#xD;OBJ01='xlabel(strXlabel);ylabel(strYlabel)'; &#xD;%---PutSize/Type_Letter_atLATEX&#xD;prop01='FontSize'; prop02='Interpreter'; INprop02='latex';&#xD;propA='XLabel'; propB='YLabel';&#xD;OBJ02='set(get(gca,propA),prop01,iFontSize,prop02,INprop02)';&#xD;OBJ03='set(get(gca,propB),prop01,iFontSize,prop02,INprop02)';&#xD;&#xD;%---- colocar legendas en graficas&#xD;OBJ05='legend(strLegend)'; propE='type';  propF='text';&#xD;OBJ06='set(findobj(lgOBJ,propE,propF),prop01,jFontSize,prop02,INprop02)';&#xD;... color y localizacion de las etiquetas&#xD;propG='boxoff'; propH='Location'; propI='edgecolor'; propJ='none';&#xD;OBJ07='legend(propG,propH,iLocLeg,propI,propJ)'&#xD;&#xD;[num, txt, raw] = xlsread('CASOIIF.XLS') &#xD;wnd=num(:,1);&#xD;&#xD;%% windFILTER&#xD;figure(1); rng default;%x=ecg(500)'+0.25*randn(500,1); %noisy waveform&#xD;&#xD;%{&#xD;xWND=[wnd;wnd]&#xD;h=fdesign.lowpass('Fp,Fst,Ap,Ast',0.15,0.2,1,60);&#xD;d=design(h,'equiripple'); %LowpassFIRFILTER&#xD;WNDfltr01=filtfilt(d.Numerator,1,xWND);%zero-phaseFILTER&#xD;WNDfltr02=filter(d.Numerator,1,xWND);%conventionalFILTER&#xD;&#xD;subplot(321);plot([WNDfltr01 WNDfltr02]);&#xD;title('señales filtradas');&#xD;legend('FILTRADO FASE-CERO','FILTRADO TRADICIONAL');&#xD;%}&#xD;xWND=[wnd]; &#xD;%subplot(211); &#xD;h=fdesign.lowpass('N,F3dB',12,0.15);  d1=design(h,'butter');&#xD;WNDfltr03=filtfilt(d1.sosMatrix,d1.ScaleValues,xWND);&#xD;&#xD;%--------------------&#xD;strYlabel='\bf{Viento (Medidas) [m/s]}';&#xD;strXlabel='\bf{Tiempo [horas]}';&#xD;strLegend={'Medici\''on sin tratar','se\~nal filtrada'};&#xD;&#xD;%plot(tm,P1_24hrs,'og',tm,P2_24hrs,'sr',tm,P3_24hrs,'^b',tm,P4_24hrs,'*k');&#xD;plot(xWND,'k-.'); hold on; plot(WNDfltr03,'r','linewidth',2);&#xD;%legend('MEDICION SIN TRATAR','SEÑAL FILTRADA','location','NorthEast');&#xD;cy = get(gca,'xtick'); &#xD;%set(gca,'xticklabel',[]);&#xD;set(gca,'xticklabel',cy/10); &#xD;eval(OBJ01); eval(OBJ02); eval(OBJ03); lgOBJ=eval(OBJ05);  eval(OBJ06);  eval(OBJ07);&#xD;axis([0 240 7.5 12.5]);grid on &#xD;%PRINT&#xD;set(gcf,'PaperUnits','centimeters','PaperOrientation','landscape',...&#xD;    'PaperType', 'A5'); pprsz=get(gcf, 'PaperSize');&#xD;[wdth hght]=deal(20,14.5);&#xD;[lft,bttm]=deal((pprsz(1)-wdth)/2,(pprsz(2)-hght)/2);&#xD;set(gcf,'PaperPosition',[lft,bttm,wdth,hght])&#xD;&#xD;nmFL='filtradoWND.pdf'; print('-dpdf',nmFL); winopen(nmFL)&#xD;</code><!-- -->  para saber que formato utilizar para desplegar datos por pantalla u archivohttp://www.mathworks.es/help/techdoc/ref/fprintf.html<!-- -->&lt;caption&gt;LATEX&lt;/caption&gt;<code>latex(S)--exportar a latex</code>http://www.mathworks.es/help/techdoc/matlab_env/f6-30186.html#brgekck&lt;dl&gt;&lt;dt&gt;tipos lineas&lt;/dt&gt;&lt;dd&gt;–: trazado lineal discontinuog: verde oscuro (green) -.: trazado lineal discontinuo intercalando punto y líneak: negro (black) : : trazado con línea de puntosm: rojo oscuro (magenta)<em>: marca *r: rojo (red)+: marca +w: blanco (white)o: círculoy: amarillo (yellow)x: marca con un aspa.: un puntob: azul (blue)c: verde claro (cyan’-^b’’-.r’&lt;/dd&gt;&lt;dt&gt;Tipo de Datos&lt;/dt&gt;&lt;dd&gt;A) ACCESO DATOS1) cell       koman2:  NameCell{n_cell}2) Numeric Arrays       koman2:  NameCell{n_cell}B = [12, 62, 93, -8, 22; 16, 2, 87, 43, 91; -4, 17, -72, 95, 6]2) Character StringsmyString = ‘Hello, world’;A) ADMINISTRACION DATOS1) Importación Datos load: Números separados por espacios-&gt; matriz Puede cargar desde ficheros .mat o ASCII load (‘fichero .mat’ [, var1, var2, varN ]) load(‘fichero ascii’) %carga matrix de números csvread → Hojas de cálculo        dlmread → Números, cualquier separador textread → para leer celdas, varios tipos   textscan → Más complejo y potente que textread xmlread → Formatos XML → Document ObjectModelExportación de datos save: Guarda datos para ser cargados con load save (‘fichero’, variables…) csvwrite dlmwrite → Números, cualquier separador xmlwrite → Guarda en formato XML&lt;/dd&gt; &lt;dt&gt;Uso general de ficheros&lt;/dt&gt;&lt;dd&gt;1.Abrir: fopen2.Lectura y escritura: fload, fwrite, fread, fscanf, fprintf…3.Cerrar: fclose, Hay que comprobar posibles errores al operar con ficheros Alternativas: Matlab(simple) y estilo C (potente)[fid, msg]=fopen(‘nombre’, ‘modo’)-Modo:- ‘r’ → fichero existente para lectura- ‘w’ → escritura, borra el contenido previo- ‘a’ → escritura, añadiendo al final del fichero- ‘r+’ → fichero existente, lectura y escritura- ‘w+’ → lectura y escritura, borrando el contenidoprevio- ‘a+’ → lectura y escritura, al final del ficherofprintf(fid, ‘formato’, variables…)- Escribe las variables en el fichero siguendo elformato indicado- Si se omite fid escribe en pantalla- Formato: cadena de conversión estilo C- %d %i: Decimal con signo- %o %u, %x: octal, sin signo, hexadecimal,- %E,e: Double precisión, notación [-]d.ddddE(+|-)dd- %f: [-]ddd.ddd; %g: usa %e o %f según el caso- %s: cadena de caracteresLectura y escritura- Longitud y decimales: %l.d antes delmodificador- Delimitadores- \n: salto de linea- \r: retorno de carro- \t: tabulador- \b: retroceso (backspace)- \: para imprimir \ (carácter de escape)Lectura- A= fscanf (fid, ‘formato’)-v=fscanf(fid, ‘%g’) → Lee todo el fichero, numero anumero, volcandolo en el vector v- [A, leidos] = fscanf(fid, ‘formato’, dimension)- Leidos= leidos correctamente- Dimension- n= n elementos en un vector columna- inf=todos los elementos- [M, N] Rellena la matriz MxN por columnas. N puede serinfLectura por lineaslinea=fgetl(fid) → lee linea a linea (singuardar \n). -1 si llega al final de fichero (sepuede comprobar con ~ischar(linea)- fgets(fid) → lee la siguiente linea, incluyendo \n- fgets(fid, nchar) → lee nchar caracteresmáximo de la siguiente lineaFormato de numerosOrden de MATLAB Comentarios Ejemploformat long format short 16 dígitos visualización por defecto 35.83333333333334 35.8333format short e 5 dígitos más exponente 3.5833e+01format long e 16 dígitos más exponente 3.583333333333334e+01format hex hexadecimal 4041eaaaaaaaaaabformat bank 2 decimales 35.83format + signo +format rat aproximación racional 215/6La orden digits(n)cambia el número de dígitos de precisión que se usa por defecto en la toolbox. La orden digits nos permite conocer cual es el valor de este número. La orden vpapermite realizar un cálculo y mostrar su resultado con una precisión especificada sin cambiar el número de dígitos de precisión con el que se trabaja por defecto. source “http://www.nebrija.es/~mjgarbayo/seminario_matlab/matlab2.html”&lt;/dd&gt;&lt;/dl&gt;<!-- -->&lt;caption&gt;matlab to latex&lt;/caption&gt; %url=http://pundit.pratt.duke.edu/piki/index.php?title=MATLAB:LaTeX_Table_Writer&amp;oldid=9734<code>%s = sym(L);&#xD; %v = vpa(s,5); %# assign numerical precision&#xD; %latex(v)&#xD;            TC = [-273.15 -40 0 100]';&#xD;            TK = TC + 273.15;&#xD;            TF = (TC+40)*9/5-40;&#xD;            TR = TF + 459.67;&#xD;&#xD;            for k=1:length(TC)&#xD;                fprintf('%8.2f &amp; %8.2f &amp; %8.2f &amp; %8.2f \\\\ \n', TC(k), TK(k), TF(k), TR(k))&#xD;            end&#xD;            &#xD;            for k=1:length(TC)&#xD;                fprintf('%8.2f &amp; %8.2f &amp; %8.2f &amp; %8.2f \\\\ \\hline  \n', TC(k), TK(k), TF(k), TR(k))&#xD;            end&#xD;            &#xD;            FID = fopen('file.tex', 'w')&#xD;            for k=1:size(MainMat, 1)&#xD;                fprintf(FID, '%8.2f &amp; %8.2f &amp; %8.2f &amp; %8.2f \\\\ \n', TC(k), TK(k), TF(k), TR(k))&#xD;            end&#xD;            fclose(FID)&#xD;            &#xD;            FID = fopen('file.tex', 'w');&#xD;            fprintf(FID, '\\begin{tabular}{|rrrr|}\\hline \n');&#xD;            fprintf(FID, 'T ($^{\\circ}$C) &amp; T (K) &amp; T ($^{\\circ}$F) &amp; T ($^{\\circ}$R)\\\\ \\hline \n');&#xD;            for k=1:length(TC)&#xD;                fprintf(FID, '%8.2f &amp; %8.2f &amp; %8.2f &amp; %8.2f \\\\ ', TC(k), TK(k), TF(k), TR(k));&#xD;                if k==length(TC)&#xD;                    fprintf(FID, '\\hline ');&#xD;                end&#xD;                fprintf(FID, '\n');&#xD;            end&#xD;             &#xD;            fprintf(FID, '\\end{tabular}\n');&#xD;            fclose(FID);&#xD;&#xD;%\begin{center}&#xD;%\input{file.tex}&#xD;%\end{center}&#xD;</code>&lt;hr&gt;&lt;caption&gt;CONFIGURACION EDITOR&lt;/caption&gt;El tipo de letra para el editor: consolasColores para el EditorAzul -&gt; RGB[0,255,204]  %Azul muy padre tirando pa verde :-Dtipos de verdes      verde-amarillo [189 221 150]      verde-azul-suave [130,239,178]      codigo ascii de caracteres utiles      0xAE – flecha      U+219 — Flecha okis      para saber el # ascii      clc;for n=126:1:255;disp([char(n) num2str(n)]);endCustomer fontstoNUMBERS-muy visible: DialogMS reference Sans Serifpalatino LinotypeMiriam FIxed LucidaCompacta: Iskoola Pota    &lt;hr&gt;&lt;caption&gt;Coordenadas Polares—&lt;/caption&gt;<code>&#xD;%PolarCoordinates&#xD;angTHT= 0:0.01:2*pi;&#xD;rdR = sin(2*angTHT).*cos(2*angTHT);&#xD;[xX,yY]=pol2cart(angTHT,rdR);&#xD;figure;plot(xX,yY)&#xD;figure; polar(angTHT,rho,'--r')</code><!--<article>-->&lt;hr&gt;&lt;caption&gt;Leer archivos o datos desde otro pc—&lt;/caption&gt;- Entras por escritorio remoto al pc[44]- Los archivos que deseas ejecutar los tienes pc[104]-Abres matlab en pc[44]-Ejecutas el siguiente ejemplo:<!----><code>dir='\\tsclient\D\MTLB\proc\StateEstimator\amediaslos2primeros';&#xD;  addpath(dir);     wls_34nudos</code><!---->y listo se ejecuta el programa sin tenerlo en tu pc<code>addpath(genpath('C:\MATLAB\R2012a\toolbox\matpower4.1'))</code><!-- -->&lt;hr&gt;&lt;caption&gt;to set ubuntu: transforn toeps desde 104 desde otro pc-&lt;/caption&gt;<code>[102]D:\lggj\code_dspace\20120222_CtrStatComBalanceado\caract&#xD;destine='\\tsclient\D\THESIS\CODE\plots_eps2pdf'; copyfile(NameFile,destine)&#xD;</code><!-- -->&lt;hr&gt;&lt;caption&gt;LECTURA / ESCRITURA DE ARCHIVO &lt;/caption&gt;<code>x = 0:.1:1;     y = [x; exp(x)];&#xD;fid = fopen('exp.m','w');     fprintf(fid,'Es letra:');&#xD;fprintf(fid,'%6.2f %12.8f\n',y);&#xD;fclose(fid)</code> http://arantxa.ii.uam.es/~iama/ficheros.pdf<!-- --><!--<h1 style="text-align:center;">multiples salidas matlab</h1>--><!-- -->&lt;hr&gt;&lt;caption&gt;para sacar muchos datos de otra funcion&lt;/caption&gt;<code>function[varargout]=ComputePointEq(sys,u_r0,u_s_eq,P_eq,Q_eq,varargin)&#xD;options=optimset('Display','off');&#xD;%Solve system of nonlinear equations&#xD;u_r_eq=fsolve(@(u_r)kk(u_r,sys,u_s_eq,P_eq,Q_eq),u_r0,options); &#xD;u=[u_s_eq;u_r_eq]; &#xD;x_eq=(eye(4)-sys.A)\(sys.B*u);&#xD;varargout{1}=u_r_eq; varargout{2}=x_eq;&#xD;end </code>&lt;/section&gt;&lt;/pre&gt;<!-- -->  &lt;footer&gt; LGGJ sec:C @uc3m&lt;/footer&gt;<time pubdate="" datetime="2012-03-01"></time><!-- --><!-- -->&lt;pre&gt;&lt;section&gt;&lt;caption&gt;LoadDatas&lt;/caption&gt; Para cuando leemos los datos a partir de un file</em>.mat<code>nmFL='datas.mat';&#xD;load(nmFL)&#xD;vars1=whos('-file',nmFL)&#xD;load(nmFL,vars1.name)&#xD;%d=load('nmFL','-regexp','x0',)&#xD;dato=importdata(nmFL)&#xD;%dato.Y.Data&#xD;%-- dato.X.Data --time&#xD;%-- dato.Y.Name -- Esto esta padre pa saber que es cada dato&#xD;nmDATA=dato.Y(1).Name, &#xD;subplot(211);&#xD;plot(dato.X.Data,dato.Y(4).Data,dato.X.Data,dato.Y(5).Data);&#xD;legend('Pmed','Pref')&#xD;subplot(212);&#xD;plot(dato.X.Data,dato.Y(6).Data,dato.X.Data,dato.Y(7).Data);&#xD;legend('Qmed','Qref')&#xD;</code><!-- -->&lt;hr&gt;&lt;caption&gt;reducir NumDatos &lt;/caption&gt;Util para cuando tienes medidas<code>tic %--- reduciendo datos&#xD;      Y1=output_discreto(:,1);&#xD;      Y2=output_discreto(:,2);&#xD;      U1=input_discreto(:,1);&#xD;      U2=input_discreto(:,2);&#xD;      n=3;&#xD;      for i=1:1:n&#xD;          Y1(1:2:end,:)=[];&#xD;          Y2(1:2:end,:)=[];&#xD;          U1(1:2:end,:)=[];&#xD;          U2(1:2:end,:)=[];&#xD;          t_stm(1:2:end,:)=[];&#xD;end&#xD;</code> <!-- -->      info matlab wer;      http://www.mathworks.es/help/techdoc/ref/f16-42340.html#f16-6755    http://www.mathworks.es/help/techdoc/ref/f16-42340.html<!-- -->&lt;caption&gt;Conocer las propiedades de un objeto&lt;/caption&gt;<code>whos objeto, whos T5_par</code>  string =&gt; character array<!-- --> &lt;body&gt;&lt;pre&gt;&lt;hr&gt;&lt;caption&gt;PROGRAMACION BASICA&lt;/caption&gt; listfonts<!--  --><b>FNCanonimous</b>http://blogs.mathworks.com/loren/2013/01/10/introduction-to-functional-programming-with-anonymous-functions-part-1/<code>c=@(a, b, theta) sqrt(a.^2+b.^2-2*a.*b.*cos(theta))&#xD;MaxMin=@(x) [min(x), max(x)];  MaxMin(2)&#xD;ans =     2     2&#xD;[extremo,idx] = cellfun(@(f) f([3 4 1 6 2]), {@min, @max})&#xD;min_and_max = @(x) cellfun(@(f) f(x), {@min, @max});&#xD;y = randi(10, 1, 10)&#xD;just_values        = min_and_max(y)&#xD;[~, just_indices]  = min_and_max(y)&#xD;[extrema, indices] = min_and_max(y)&#xD;mapc = @(val, fcns) cellfun(@(f) f(val{:}), fcns, 'UniformOutput', false);&#xD;mapc({pi}, {@(x) 2 * x, ...                     % Multiply by 2&#xD;            @cos, ...                           % Find cosine&#xD;            @(x) sprintf('x is %.5f...', x)})   % Return a string&#xD;MIO:&#xD;mapc=@(val,fcns) cellfun(@(f) f(val{:}),fcns,'UniformOutput',false);&#xD;oxx=mapc({230}, {@(x)x*sqrt(2/3),@cos,@(x) sprintf('x is %.5f...', x)})  &#xD;</code><b>Integrales </b> http://www.cs.cmu.edu/~tom/10601_fall2012/recitations/matlab_quickref.pdf<code>f1=inline(’1./(2*x.^3-2*x-5)’); Q=quad(f1,0,2);&#xD;f2=@(x)1./(2*x.^3-2*x-5);Q=quad(f2,0,2);</code><!--  --><b>Edit Folders, Filese</b><!--  --><code>movefile('source','destination')</code><!--  --><b> function symbolicas</b> si se usa una funcion simbolica se puede  substituir valor con <b>subs </b><!--  --><!--  -->&lt;hr&gt;<b>STRINGS</b><!--  -->a = ‘hello  ‘;      b = ‘goodbye’;    using_strcat = strcat(a, b)    using_arrayop = [a, b]      % Equivalent to horzcat(a, b)     MATLAB returns    using_strcat =hellogoodbye    using_arrayop =hello  goodbye    alfabeto griego en latex para matlab<!--  --><b>String Evaluation</b>  <code>eval, feval</code><b>multiplicacion matrices</b><code>clear all; close all; clc %% multiplicacion Matrix&#xD;%a(mn)&#xD;syms a11 a12 a13 %a11...a1n&#xD;syms a21 a22 a23 &#xD;syms a31 a32 a33 %am1..anm&#xD;%b(np)&#xD;syms b11  %b11...b1p&#xD;syms b21  &#xD;syms b31  %bn1..anp&#xD;&#xD;A=[a11,a12,a13;...&#xD;a21,a22,a23;...&#xD;a31,a32,a33]; %am1..anm&#xD;B=[b11;b21;b31]; C=A*B&#xD;</code><!--  -->&lt;hr&gt;<b> MATRIX</b>Para sumar los elementos de una matrix<code>  [baseMVA, bus, gen, branch] = loadcase(casefile);&#xD;    % obtener el vector de las potencias &#xD;    P=bus(:,3);    Q=bus(:,4);&#xD;    PQ=bus([1:4],[3 4]) %submatrix elementos donde se interseptan filas 1,4  y columnas 3,4&#xD;    % en la primera prueba usamos todas la potencias para que sea la total&#xD;    Pt_test1=sum(P,1) % 1 es para que sume en vertical&#xD;    Qt_test1=sum(Q,1)% 1 es para que sume en vertical&#xD;    PQ_1=sum(PQ,1)&#xD;    % en la segunda prueba solo emplearemos las 3 primeras cargas&#xD;    PQ_tst2=bus([1:3],[3 4])%submatrix elementos donde se interseptan filas 1,3  y columnas 3,4&#xD;    PQ_2=sum(PQ_tst2,1)  &#xD;    source:algabra matlab</code> <!--  -->   &lt;hr&gt;<b>VECTORES</b>dot-product of two vectors – norm(V)cross computes the cross product of two vectors in R3.<!--  -->&lt;hr&gt;&lt;caption&gt; ATAJOS KOman2&lt;/caption&gt;  Para seleccionar matlab con el tabulador  para seleccionar en la barra superior Alt+ F E V b D W H<!--  --><b> abrir archivos de un pc remoto:</b><code>strcat(old_dir,'\',NameFile)</code> $ en el path colocar &lt;- \tsclient\D)<!--  -->  &lt;hr&gt;&lt;caption&gt; FOLDERs&lt;/caption&gt; <b>MOVER ARCHIVO AL FOLDER CHILDREN </b> <code>carpeta destino&#xD;  NameFolderChildren='sub01'&#xD;  copyfile('source','destination') &#xD;   NameFolderChildren='sub01'&#xD;   NameFile='dt_2G_8buses.m'&#xD;          source=strcat(old_dir,'\',NameFile)&#xD;          destino=strcat(old_dir,'\',NameFolderChildren,'\',NameFile)<br />&#xD;copyfile(source,destino)</code><!--  -->       <b>MOVER FILE</b><code>NameFile='datos_fglongatt.m'&#xD;  source=strcat(old_dir,'\',NameFile)&#xD;  destino=strcat(old_dir,'\',NameFolderChildren,'\',NameFile)&#xD;  movefile(source,destino) </code><!--  -->    &lt;hr&gt;<b>abrir archivos de un pc remoto:</b>function anonymous:   A = [2 3 4];<br />B = [5 6 7];      sumAxBy = @(x, y) (A<em>x + B</em>y);      sumAxBy(5, 7)<!--  --> Code performance checkcode(‘filename’) Inilation variables function q = fcnPersist1(u)% fcnPersistent creates and uses a      persistent variable.persistent y; <br /> if isempty(y),    y = u;<br />else,    y = y+1;<br />end q = y;)<!-- <br>  --> &lt;hr&gt;<b>FOR-CICLOS: </b>         <tt> syms a11 a12 b21 b22             A=[a11;a12];             B=[b21;b22];            % mover              for i=1:1:2;              for j=1:1:2;             fprintf(‘i=%d j=%d \n’,i,j)               C(i,j)=A(i)*B(j);             fprintf(‘Matrix C \n’);              disp(C); pause(1)            end          end </tt> <!--  --> &lt;hr&gt;<b>MOVE folder:</b> $para mover un archivo a un children_folder      &lt;- algun comentario necesario<!-- --><!--  -->   <b>INDICAR DIRECCION ACTUAL</b> old_dir=pwd;  B=[b21;b22];<!--  -->          <b>CARPETA DESTINO</b><!-- --><code>NameFolderChildren='sub01' &#xD;      copyfile('source','destination')&#xD;      NameFolderChildren='sub01';&#xD;      NameFile='dt_2G_8buses.m'&#xD;      source=strcat(old_dir,'\',NameFile)&#xD;      destino=strcat&#xD;      (old_dir,'\',NameFolderChildren,'\',NameFile)&#xD;      copyfile(source,destino)</code></p>
:ET