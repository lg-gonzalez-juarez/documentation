I"<h2 id="41-unary-and-bitwise-operators">4.1. Unary and Bitwise Operators</h2>

<p>Before we start using the types that we’ve learned to write larger scripts with, we’re going to want to know about the operators that we have access to. In this lesson, we’ll be defining unary and bitwise operators.</p>

<p>Documentation</p>

<ul>
  <li><a href="https://wiki.python.org/moin/BitwiseOperators">Python Bitwise Operator Documentation</a></li>
  <li><a href="https://docs.python.org/3/library/operator.html#mapping-operators-to-functions">Python Operators</a></li>
</ul>

<h3 id="what-is-a-unary-operator">What is a Unary Operator?</h3>

<p>A unary operator is an operator that only has one operand. Where the + operation is a binary operator, because we need to provide an operand to the right and left of the operator, a unary operator only takes a right-side operand.</p>

<h3 id="what-are-bitwise-operators">What are Bitwise Operators?</h3>

<p>Bitwise operators are operators that work off of the bit information (binary notation) for numbers. These aren’t used that often, but it’s good to have an understanding of what they do.</p>

<p>Positions in binary numbers are known as “bits” and they can either be 0 or 1. Bitwise operations do various things based on the values of these bits.</p>

<h3 id="a-brief-aside-about-truth-tables">A Brief Aside About Truth Tables</h3>

<p>One tool from logic (from philosophy) that is used at every level of computer science is the idea of truth tables. Truth tables describe how various operations in boolean algebra work, and can show us all of the available options. Bitwise operators are boolean algebra operations because they deal with 0 and 1, which will equate to false and true. We won’t go too deep into truth tables, but if you’d like to have a better understanding of boolean logic then I would encourage you to research them.</p>

<h3 id="operators-bitwise-complement">Operators: Bitwise Complement</h3>

<p>The first bitwise operator that we’re going to talk about is probably the most confusing one: the bitwise complement operator <code class="language-plaintext highlighter-rouge">~</code>. This is the only unary operator that we’re going to talk about in this lesson. It takes a number that we’re going to call x, and returns the result of <code class="language-plaintext highlighter-rouge">-x - 1</code>. To show what this looks like in binary we’ll also use the <code class="language-plaintext highlighter-rouge">bin</code> function to show our integers as binary numbers:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; a = 0b010
2
&gt;&gt;&gt; bin(a)
'0b10'
&gt;&gt;&gt; ~a
-3
&gt;&gt;&gt; bin(~a)
'-0b11'
</code></pre></div></div>

<h3 id="bitwise-or">Bitwise OR</h3>

<table>
  <tbody>
    <tr>
      <td>The remainder of the bitwise operators make a lot more sense and require two numbers as the operands. The bitwise OR operation will take two numbers, and if one of them has a 1 in a bit position then it will return a 1 at that position in the final result. To use the bitwise OR we’ll use a single pipe characters</td>
      <td>:</td>
    </tr>
  </tbody>
</table>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; a = 0b1001
&gt;&gt;&gt; b = 0b1100
&gt;&gt;&gt; bin(a | b)
'0b1101'
</code></pre></div></div>

<h3 id="bitwise-and">Bitwise AND</h3>

<p>Where bitwise OR will return a 1 for a bit position if that position is a 1 in either number, bitwise AND requires that both have a 1 at that position, otherwise it will have a 0 at that position in the final result. The bitwise AND operator is a single ampersand &amp;:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; a = 0b1001
&gt;&gt;&gt; b = 0b1100
&gt;&gt;&gt; bin(a &amp; b)
'0b1000'
</code></pre></div></div>

<h3 id="bitwise-xor">Bitwise XOR</h3>

<p>Bitwise XOR (exclusive or) is an interesting operator where the position in the final result will have a 1 if exactly one of the operands has a 1 in that position. The bitwise XOR operator is a caret ^:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; a = 0b1001
&gt;&gt;&gt; b = 0b1100
&gt;&gt;&gt; bin(a ^ b)
'0b101'
</code></pre></div></div>

<h3 id="bitwise-right-shift">Bitwise Right Shift</h3>

<p>The final two operators allow us to shift our bit values directly sideways by a certain number of positions. To shift our bits to the right we’ll use the bitwise right shift operator which is ». Our initial values are on the left-hand side and the number of positions to shift is on the right:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; a = 0b110
&gt;&gt;&gt; bin(a &gt;&gt; 2)
'0b1'
&gt;&gt;&gt; bin(a &gt;&gt; 4)
'0b0'
</code></pre></div></div>

<p>Notice that if we shift beyond the number of bits in our number then we simply get 0 as the result.</p>

<h3 id="bitwise-left-shift">Bitwise Left Shift</h3>

<p>Bitwise left shift uses the « operator with the same rules as the right shift operator. For each position that we shift then we’ll add a new 0 bit to the right.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; a = 0b110
&gt;&gt;&gt; bin(a &lt;&lt; 2)
'0b11000'
&gt;&gt;&gt; bin(a &lt;&lt; 4)
'0b1100000''
</code></pre></div></div>
<h2 id="42-boolean-operators">4.2 Boolean Operators</h2>

<p>Believe it or not, now that we understand bitwise operators we’ve learned the basics of doing boolean logic. We’re in a great spot to learn about boolean operators.</p>

<p>Python Documentation: <a href="https://docs.python.org/3/library/stdtypes.html#boolean-operations-and-or-not">Boolean Operators</a></p>

<h3 id="the-not-operation">The not Operation</h3>
<p>Sometimes we want to know the opposite boolean value for something. To do this, we use the unary operators <code class="language-plaintext highlighter-rouge">not</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; not True
False
&gt;&gt;&gt; not False
True
</code></pre></div></div>

<h3 id="the-or-operation">The or Operation</h3>

<p>The boolean <code class="language-plaintext highlighter-rouge">or</code> operator works the same way that the bitwise OR operator did if we are only considering one bit. The bit of <code class="language-plaintext highlighter-rouge">1</code> is equivalent to <code class="language-plaintext highlighter-rouge">True</code> and <code class="language-plaintext highlighter-rouge">0</code> is equivalent to <code class="language-plaintext highlighter-rouge">False</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; True or True
True
&gt;&gt;&gt; True or False
True
&gt;&gt;&gt; False or False
False
&gt;&gt;&gt; False or True
True
</code></pre></div></div>

<h3 id="the-and-operation">The and Operation</h3>

<p>The <code class="language-plaintext highlighter-rouge">and</code> operator is the opposite of <code class="language-plaintext highlighter-rouge">or</code>, and both of the operands need to be true.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; True and True
True
&gt;&gt;&gt; True and False
False
&gt;&gt;&gt; False and False
False
&gt;&gt;&gt; False and True
False
</code></pre></div></div>
:ET