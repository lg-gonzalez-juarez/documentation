I"ã<p>vcbcv</p>

<h2 id="431-creating-and-using-python-modules">43.1. Creating and Using Python Modules</h2>

<p>To have truly reusable code, we need to access functions, variables, and objects that have already been written. Thus we need to have a way to share our code. This is where modules and packages are useful. In this lesson, we demonstrate how to create our first Python module and access its contents from a different Python program.</p>

<p>Documentation</p>
<ul>
  <li><a href="https://docs.python.org/3/tutorial/modules.html">Python Modules Documentation</a></li>
  <li><a href="https://docs.python.org/3/reference/simple_stmts.html#import">The import Statement</a></li>
</ul>

<h3 id="what-is-a-module">What Is a Module?</h3>

<p>Working with Python it‚Äôs very easy to define new functions and assign values to variables that we would like to use multiple times. It would be great if we could write these useful pieces of code once and then use them whenever we need them. Thankfully, we can do just that because of modules. In Python, a module is just a Python file. This means that we can use modules to divide our code into logical groupings by putting them into separate modules and then pulling those modules into our scripts or applications when we need them.</p>

<h3 id="creating-our-first-module">Creating Our First Module</h3>
<p>To demonstrate how to create and use modules, let‚Äôs create a new directory called <code class="language-plaintext highlighter-rouge">using_modules</code>. Within it, we‚Äôll define our first module by creating the <code class="language-plaintext highlighter-rouge">using_modules/helpers.py</code> file.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ mkdir ~/using_modules
$ cd ~/using_modules
$ touch helpers.py
</code></pre></div></div>

<p>Within <code class="language-plaintext highlighter-rouge">helpers.py</code>, we‚Äôre placing some functions that we think will be generally useful and likely to be used in other files. Let‚Äôs write a few functions that can manipulate strings. <code class="language-plaintext highlighter-rouge">~/using_modules/helpers.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def extract_upper(phrase):
    return list(filter(str.isupper, phrase))

def extract_lower(phrase):
    return list(filter(str.islower, phrase))
</code></pre></div></div>

<p>Now we have two functions defined and we‚Äôd like to use them in other scripts and modules.</p>

<h3 id="using-our-module-from-another-script">Using Our Module from Another Script</h3>

<p>For this section of the course, we‚Äôre going to be putting our example code into a script called main.py. Let‚Äôs create that script now and look at what we can do to pull in these functions so that we can use them.</p>

<p>The key to working with modules is the <a href="https://docs.python.org/3/reference/simple_stmts.html#import">import statement</a> . We‚Äôre going to dig deeper into all that we can do while importing modules in the next lesson. But for now, we‚Äôre going to leverage the fact that we can import modules in the same directory as our script by referencing them by their file name minus the extension. In our case, this will <code class="language-plaintext highlighter-rouge">be helpers</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/using_modules/main.py
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import helpers
</code></pre></div></div>

<p>Before we use our functions, let‚Äôs make sure that this file is valid by running it.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3.7 main.py
$
No output is a good sign. To utilize the functions defined in our module, we'll add a period to the end of our module name (i.e. the file name) and then type the name of our function to call it as we otherwise would.

~/using_modules/main.py

import helpers

name = "Keith Thompson"
print(f"Lowercase letters: {helpers.extract_lower(name)}")
print(f"Uppercase letters: {helpers.extract_upper(name)}")
Let's run this and verify it works as expected.

$ python3.7 main.py
Lowercase letters: ['e', 'i', 't', 'h', 'h', 'o', 'm', 'p', 's', 'o', 'n']
Uppercase letters: ['K', 'T']

</code></pre></div></div>

<p>Perfect! Now we know the simplest way to define and use modules. In the next lesson, we‚Äôll dig deeper into the various ways and places that we can import modules.</p>

<h2 id="432-importing-modules">43.2. Importing Modules</h2>

<p>Python provides a few different ways to import modules and packages. In this lesson, we‚Äôll take a look at how importing works and the various ways we can import definitions from a module.</p>

<h3 id="documentation">Documentation</h3>
<ul>
  <li><a href="https://docs.python.org/3/tutorial/modules.html">Python Modules Documentation</a></li>
  <li><a href="https://docs.python.org/3/reference/simple_stmts.html#import">The import Statement</a></li>
</ul>

<h2 id="the-standard-import-statement">The Standard import Statement</h2>

<p>When we learned how to create a module, we also learned how to import the module as a singular entity into other Python files. To reiterate this, we use the following format to import an entire module under its namespace.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import my_module_name
</code></pre></div></div>

<p>By doing this, we‚Äôre able to access anything exposed by the module by chaining off of the module‚Äôs name. Occasionally, we might have a naming conflict when importing a module. In those cases, we can also use the keyword <code class="language-plaintext highlighter-rouge">as</code> in the <code class="language-plaintext highlighter-rouge">import</code> statement to change the identifier that we use to represent the module. Let‚Äôs change our <code class="language-plaintext highlighter-rouge">using_modules/main.py</code> so that the <code class="language-plaintext highlighter-rouge">helpers</code> module is accessed using the h name.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/using_modules/helpers.py
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import helpers as h

name = "Keith Thompson"
print(f"Lowercase letters: {h.extract_lower(name)}")
print(f"Uppercase letters: {h.extract_upper(name)}")
</code></pre></div></div>

<p>The name of <code class="language-plaintext highlighter-rouge">h</code> isn‚Äôt great, but it does demonstrate that we can change the name of modules when we import them. If we run this script, we will see there‚Äôs no difference in the output.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3.7 main.py
Lowercase letters: ['e', 'i', 't', 'h', 'h', 'o', 'm', 'p', 's', 'o', 'n']
Uppercase letters: ['K', 'T']
</code></pre></div></div>

<h3 id="importing-from">Importing from</h3>

<p>More often than not, we don‚Äôt need to use everything provided by a module. In these cases, we can leverage the <code class="language-plaintext highlighter-rouge">from</code> version of an <code class="language-plaintext highlighter-rouge">import</code> statement to import only the definitions we need from the module, and then we can access them directly. To demonstrate how to do this for multiple functions, let‚Äôs directly import the functions from our <code class="language-plaintext highlighter-rouge">helpers</code> module. The <code class="language-plaintext highlighter-rouge">from</code> statement works like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from &lt;MODULE_NAME&gt; import &lt;definition&gt;, &lt;definition&gt;, &lt;etc.&gt;
</code></pre></div></div>

<p>Here‚Äôs what it looks like in <code class="language-plaintext highlighter-rouge">main.py</code>:</p>

<p><code class="language-plaintext highlighter-rouge">~/using_modules/main.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from helpers import extract_lower, extract_upper

name = "Keith Thompson"
print(f"Lowercase letters: {extract_lower(name)}")
print(f"Uppercase letters: {extract_upper(name)}")
</code></pre></div></div>

<p>It‚Äôs worth noting that now we don‚Äôt have access to the <code class="language-plaintext highlighter-rouge">helpers</code> name in our code at all. If we change our <code class="language-plaintext highlighter-rouge">extract_upper</code> line to be chained off of <code class="language-plaintext highlighter-rouge">helpers</code> name it will cause an error.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3.7 main.py
Lowercase letters: ['e', 'i', 't', 'h', 'h', 'o', 'm', 'p', 's', 'o', 'n']
Traceback (most recent call last):
  File "using_modules/main.py", line 5, in &lt;module&gt;
    print(f"Uppercase letters: {helpers.extract_upper(name)}")
NameError: name 'helpers' is not defined
</code></pre></div></div>

<p>Lastly, we can also combine the <code class="language-plaintext highlighter-rouge">as</code> keyword with each definition that we‚Äôre importing to explicitly rename that definition.</p>

<p><code class="language-plaintext highlighter-rouge">~/using_modules/main.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from helpers import extract_lower as e_low, extract_upper

name = "Keith Thompson"
print(f"Lowercase letters: {e_low(name)}")
print(f"Uppercase letters: {extract_upper(name)}")
</code></pre></div></div>

<h3 id="importing-everything-from-a-module">Importing Everything from a Module</h3>

<p>The final way we can import definitions from a module is to import all of them at once by using <code class="language-plaintext highlighter-rouge">*</code>. This is generally not the recommended way of importing things, but sometimes a module provides a lot of functions that we‚Äôll be using, and we don‚Äôt want to explicitly import them one at a time.</p>

<p>Let‚Äôs utilize the <code class="language-plaintext highlighter-rouge">*</code> to import our two functions from the <code class="language-plaintext highlighter-rouge">helpers</code> module without explicitly naming them.</p>

<p><code class="language-plaintext highlighter-rouge">~/using_modules/main.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from helpers import *

name = "Keith Thompson"
print(f"Lowercase letters: {extract_lower(name)}")
print(f"Uppercase letters: {extract_upper(name)}")
</code></pre></div></div>

<p>Once again, if we run this, it will work just as it did before.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3.7 main.py
Lowercase letters: ['e', 'i', 't', 'h', 'h', 'o', 'm', 'p', 's', 'o', 'n']
Uppercase letters: ['K', 'T']
</code></pre></div></div>

<h2 id="433-executing-modules-as-scripts">43.3. Executing Modules as Scripts</h2>

<p>Python modules are just files, but sometimes we want them to behave slightly differently if they‚Äôre being run directly. In this lesson, we‚Äôll learn about how modules are interpreted when imported and also how to only run code when a module is run directly by using the <strong>name</strong> variable.</p>

<h3 id="documentation-1">Documentation</h3>

<ul>
  <li><a href="https://docs.python.org/3/tutorial/modules.html">Python Modules Documentation</a></li>
  <li><a href="https://docs.python.org/3/reference/simple_stmts.html#import">The import Statement</a></li>
  <li><a href="https://docs.python.org/3/library/__main__.html">The <strong>name</strong> Variable</a></li>
</ul>

<h3 id="expressions-in-a-module">Expressions in a Module</h3>

<p>Since modules are just Python files, they can contain expressions and the file will be interpreted from top to bottom. So a few good questions to ask ourselves are:</p>

<ol>
  <li>When is a module interpreted?</li>
  <li>Can a module be interpreted twice?</li>
</ol>

<p>To test this, let‚Äôs create another module that imports our <code class="language-plaintext highlighter-rouge">helpers</code> module and also import that new module into our <code class="language-plaintext highlighter-rouge">main.py</code>. We‚Äôll call this module <code class="language-plaintext highlighter-rouge">extras.py</code>.</p>

<p><code class="language-plaintext highlighter-rouge">~/using_modules/extras.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>print("Importing 'helpers' in 'extras'")
import helpers

name = "Keith Thompson"
</code></pre></div></div>

<p>In <code class="language-plaintext highlighter-rouge">main.py</code>, let‚Äôs import extras.</p>

<p><code class="language-plaintext highlighter-rouge">~/using_modules/main.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>print("We're importing 'helpers' from 'main'")
from helpers import *

print("We're importing 'extras' from 'main'")
import extras

print(f"Lowercase letters: {extract_lower(extras.name)}")
print(f"Uppercase letters: {extract_upper(extras.name)}")
</code></pre></div></div>

<p>Finally, in <code class="language-plaintext highlighter-rouge">helpers.py</code> we‚Äôll add <code class="language-plaintext highlighter-rouge">print</code>, so that we can see when it is run and how many times it is run.</p>

<p><code class="language-plaintext highlighter-rouge">~/using_modules/helpers.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def extract_upper(phrase):
    return list(filter(str.isupper, phrase))

def extract_lower(phrase):
    return list(filter(str.islower, phrase))

print("HELLO FROM HELPERS")
</code></pre></div></div>

<p>We now have enough print lines to helps us really see how <code class="language-plaintext highlighter-rouge">main.py</code> is processed and when our modules are interpreted. When we run it, this is what we see:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3.7 main.py

We're importing 'helpers' from 'main'
HELLO FROM HELPERS
We're importing 'extras' from 'main'
We're import 'helpers' from 'extras'
Lowercase letters: ['e', 'i', 't', 'h', 'h', 'o', 'm', 'p', 's', 'o', 'n']
Uppercase letters: ['K', 'T']
</code></pre></div></div>

<p>As we can see, the code within the <code class="language-plaintext highlighter-rouge">helpers</code> module was only interpreted the first time that it was imported. So even though it was imported into two different modules, it was only ever run one time.</p>

<h3 id="running-a-module-directly">Running a Module Directly</h3>

<p>Ideally, we don‚Äôt want to run this <code class="language-plaintext highlighter-rouge">print</code> line when our module is imported, but sometimes we do want a module to execute something if it is run directly. To handle this, we can access the <code class="language-plaintext highlighter-rouge">__name__</code> variable. The <code class="language-plaintext highlighter-rouge">__name__</code> variable is set in each module and can be used to determine if the module is being run directly as opposed to being imported. Let‚Äôs change the various print lines from our previous lesson to help us understand the values set to <code class="language-plaintext highlighter-rouge">__name__</code> in each of our scripts.</p>

<p><code class="language-plaintext highlighter-rouge">~/using_modules/main.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from helpers import *
import extras

print(f"__name__ in main.py: {__name__}")

print(f"Lowercase letters: {extract_lower(extras.name)}")
print(f"Uppercase letters: {extract_upper(extras.name)}")
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">~/using_modules/helpers.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def extract_upper(phrase):
    return list(filter(str.isupper, phrase))

def extract_lower(phrase):
    return list(filter(str.islower, phrase))

print(f"__name__ in helpers.py: {__name__}")
print("HELLO FROM HELPERS")
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">~/using_modules/extras.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import helpers

print(f"__name__ in extras.py: {__name__}")

name = "Keith Thompson"
Here's what we see when we run main.py:
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">$ python3.7 main.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>__name__ in helpers.py: helpers
HELLO FROM HELPERS
__name__ in extras.py: extras
__name__ in main.py: __main__
Lowercase letters: ['e', 'i', 't', 'h', 'h', 'o', 'm', 'p', 's', 'o', 'n']
Uppercase letters: ['K', 'T']
</code></pre></div></div>

<p>All of the modules that we imported have <code class="language-plaintext highlighter-rouge">__name__</code> set to the actual module name, but main.py is set to <code class="language-plaintext highlighter-rouge">__main__</code> because it is running in the main context. A common pattern is to add a condition like this if we want to add functionality to a module only if it is running in the main context:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if __name__ == "__main__":
    print("Something only when running in main scope")
</code></pre></div></div>

<p>To demonstrate this, let‚Äôs remove all of these debugging lines, but move ‚ÄúHELLO FROM HELPERS‚Äù into this conditional in <code class="language-plaintext highlighter-rouge">helpers.py</code>.</p>

<p>(We‚Äôre only showing the change to <code class="language-plaintext highlighter-rouge">helpers.py</code>, but we removed all of the <code class="language-plaintext highlighter-rouge">'__name__</code> in ‚Ä¶‚Äô output)</p>

<p><code class="language-plaintext highlighter-rouge">~/using_modules/helpers.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def extract_upper(phrase):
    return list(filter(str.isupper, phrase))

def extract_lower(phrase):
    return list(filter(str.islower, phrase))

if __name__ == "__main__":
    print("HELLO FROM HELPERS")
</code></pre></div></div>
<p>If we now run <code class="language-plaintext highlighter-rouge">main.py</code> we should see the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3.7 main.py
Lowercase letters: ['e', 'i', 't', 'h', 'h', 'o', 'm', 'p', 's', 'o', 'n']
Uppercase letters: ['K', 'T']
</code></pre></div></div>

<p>If we run <code class="language-plaintext highlighter-rouge">helpers.py</code> directly, we should see the print line being run.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3.7 helpers.py
HELLO FROM HELPERS
</code></pre></div></div>

<h2 id="434-hiding-module-entities">43.4. Hiding Module Entities</h2>

<p>Now that we know how to import our modules, we might want to restrict what is exposed. In this lesson, we‚Äôll look at how we can hide some of our module‚Äôs contents from being imported by other modules and scripts.</p>

<h3 id="documentation-2">Documentation</h3>

<p><a href="https://docs.python.org/3/tutorial/modules.html">Python Modules Documentation</a></p>

<h3 id="what-are-module-entities">What Are Module Entities?</h3>

<p>When we see <code class="language-plaintext highlighter-rouge">module entities</code>, we need to see <code class="language-plaintext highlighter-rouge">variables</code>, <code class="language-plaintext highlighter-rouge">functions</code>, and <code class="language-plaintext highlighter-rouge">classes</code> (we‚Äôll cover classes in the next section). A module entity is anything we provide with a name in our module. As we‚Äôve seen, these things are importable by name when we used <code class="language-plaintext highlighter-rouge">from &lt;module&gt; import &lt;name&gt;</code>.</p>

<h3 id="using-__all__">Using <code class="language-plaintext highlighter-rouge">__all__</code></h3>

<p>If we want to prevent someone from importing an entity from our module, there aren‚Äôt very many options. There are only two reasonable things we can do to restrict what is imported if someone uses from <code class="language-plaintext highlighter-rouge">&lt;module&gt; import *</code>. The first is by setting the <code class="language-plaintext highlighter-rouge">__all__</code> variable in our module. Let‚Äôs test this out by setting <code class="language-plaintext highlighter-rouge">__all__</code> to a list including only <code class="language-plaintext highlighter-rouge">extract_upper</code> to see what happens in <code class="language-plaintext highlighter-rouge">main.py</code>.</p>

<p><code class="language-plaintext highlighter-rouge">~/using_modules/helpers.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>__all__ = ["extract_upper"]

def extract_upper(phrase):
    return list(filter(str.isupper, phrase))

def extract_lower(phrase):
    return list(filter(str.islower, phrase))

if __name__ == "__main__":
    print("HELLO FROM HELPERS")
</code></pre></div></div>

<p>In <code class="language-plaintext highlighter-rouge">main.py</code>, we had been using both of these functions after loading them with <code class="language-plaintext highlighter-rouge">from helpers import *</code>. Here‚Äôs another look at what <code class="language-plaintext highlighter-rouge">main.py</code> currently looks like.</p>

<p><code class="language-plaintext highlighter-rouge">~/using_modules/main.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from helpers import *
import extras

print(f"Lowercase letters: {extract_lower(extras.name)}")
print(f"Uppercase letters: {extract_upper(extras.name)}")
</code></pre></div></div>

<p>With <code class="language-plaintext highlighter-rouge">__all__</code> set in <code class="language-plaintext highlighter-rouge">helpers</code>, let‚Äôs run <code class="language-plaintext highlighter-rouge">main.py</code> to see what happens.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3.7 main.py
Traceback (most recent call last):
  File "main.py", line 4, in &lt;module&gt;
    print(f"Lowercase letters: {extract_lower(extras.name)}")
NameError: name 'extract_lower' is not defined
</code></pre></div></div>

<p>Although <code class="language-plaintext highlighter-rouge">name</code> exists within <code class="language-plaintext highlighter-rouge">helpers.py</code>, it is not available in other modules via <code class="language-plaintext highlighter-rouge">from helpers import *</code>. This does not mean that we can‚Äôt explicitly import <code class="language-plaintext highlighter-rouge">extract_lower</code> though. Let‚Äôs modify <code class="language-plaintext highlighter-rouge">main.py</code> to import <code class="language-plaintext highlighter-rouge">extract_lower</code> by name.</p>

<p><code class="language-plaintext highlighter-rouge">~/using_modules/main.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from helpers import *
from helpers import extract_lower
import extras

print(f"Lowercase letters: {extract_lower(extras.name)}")
print(f"Uppercase letters: {extract_upper(extras.name)}")
</code></pre></div></div>

<p>Let‚Äôs run this one more time.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3.7 main.py
Lowercase letters: ['e', 'i', 't', 'h', 'h', 'o', 'm', 'p', 's', 'o', 'n']
Uppercase letters: ['K', 'T']
</code></pre></div></div>

<p>While it doesn‚Äôt allow us to prevent an entity from ever being imported, using <code class="language-plaintext highlighter-rouge">__all__</code> does provide a way of sometimes restricting what is imported by modules and scripts consuming our modules and packages.</p>

<h3 id="using-underscored-entities">Using Underscored Entities</h3>

<p>The other way we can prevent an entity from being exported automatically when someone uses <code class="language-plaintext highlighter-rouge">from &lt;module&gt; import *</code> is by making the first character an underscore <code class="language-plaintext highlighter-rouge">(_)</code>. If we removed <code class="language-plaintext highlighter-rouge">__all__ </code>from <code class="language-plaintext highlighter-rouge">helpers.py</code> and created a variable called <code class="language-plaintext highlighter-rouge">_hidden_var = "test"</code>, we would not have access to <code class="language-plaintext highlighter-rouge">_hidden_var</code> after running <code class="language-plaintext highlighter-rouge">from helpers import *</code>.</p>

<h2 id="435-the-module-search-path">43.5. The Module Search Path</h2>

<p>We‚Äôve seen how to create our modules, and we‚Äôve been able to import them from scripts adjacent to them in the file system, but where else can we import modules from?</p>

<h3 id="documentation-3">Documentation</h3>
<ul>
  <li><a href="https://docs.python.org/3/tutorial/modules.html">Python Modules Documentation</a></li>
  <li><a href="https://docs.python.org/3/library/">Python Standard Libary</a></li>
  <li><a href="https://docs.python.org/3/library/sys.html">Sys Module</a></li>
</ul>

<h3 id="where-do-modules-come-from">Where Do Modules Come From?</h3>

<p>Python is a language with a large and powerful <a href="https://docs.python.org/3/library/">standard library</a> of modules. To use these modules, we need to import them the same way that we‚Äôve been importing our local modules, but how does Python know where to find the code for these modules? To understand this we need to look at the module search path. When Python goes looking for a module it has a path that works very much like the <code class="language-plaintext highlighter-rouge">PATH</code> variable used by our shell to find executables. A few different things are combined to make this path:</p>

<ul>
  <li>The directory containing the running script is automatically the first item in the search path. When running the REPL this will be the current directory.</li>
  <li>The values set in the <code class="language-plaintext highlighter-rouge">PYTHONPATH</code> environment variable (if it is set) will be next in the list.</li>
  <li>Finally, a list of directories configured when Python was installed. This list contains paths to directories that have the standard library modules and other packages we‚Äôve installed.</li>
</ul>

<p>If we want to see the module search path, we can import the <a href="https://docs.python.org/3/library/sys.html">sys</a> module and view the <code class="language-plaintext highlighter-rouge">path</code> variable. Let‚Äôs do this from a REPL.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3.7
Python 3.7.6 (default, Jan 29 2020, 21:20:26)
[GCC 4.8.5 20150623 (Red Hat 4.8.5-39)] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path
['', '/home/cloud_user/.pyenv/versions/3.7.6/lib/python37.zip', '/home/cloud_user/.pyenv/versions/3.7.6/lib/python3.7', '/home/cloud_user/.pyenv/versions/3.7.6/lib/python3.7/lib-dynload', '/home/cloud_user/.pyenv/versions/3.7.6/lib/python3.7/site-packages']
&gt;&gt;&gt; exit()
</code></pre></div></div>

<p>Our Python install is in <code class="language-plaintext highlighter-rouge">~/.pyenv/versions/3.7.6</code>, and the directories within contain the standard library. The <code class="language-plaintext highlighter-rouge">site-packages</code> directory contains third-party packages that we might install.</p>

<p>Just to show that we can change this, let‚Äôs set the <code class="language-plaintext highlighter-rouge">PYTHONPATH</code> environment variable when starting the REPL.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ PYTHONPATH=/home/cloud_user python3.7
Python 3.7.6 (default, Jan 29 2020, 21:20:26)
[GCC 4.8.5 20150623 (Red Hat 4.8.5-39)] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path
['', '/home/cloud_user', '/home/cloud_user/.pyenv/versions/3.7.6/lib/python37.zip', '/home/cloud_user/.pyenv/versions/3.7.6/lib/python3.7', '/home/cloud_user/.pyenv/versions/3.7.6/lib/python3.7/lib-dynload', '/home/cloud_user/.pyenv/versions/3.7.6/lib/python3.7/site-packages']
&gt;&gt;&gt; exit()
</code></pre></div></div>

<p>Now we can see that <code class="language-plaintext highlighter-rouge">/home/cloud_user</code> is the second item in the list. If we don‚Äôt have a package in our current directory (the ‚Äò‚Äô in the list), then it will check items passed in via <code class="language-plaintext highlighter-rouge">PYTHONPATH</code> before looking at items provided by our Python installation.</p>

<p>Note: Python will search for a built-in module by name before searching the paths in <code class="language-plaintext highlighter-rouge">sys.path</code>. This means you can‚Äôt accidentally create a module with the same name as a built-in module, which prevents you from overwriting the built-in module.</p>

<h2 id="436-creating-and-using-python-packages">43.6. Creating and Using Python Packages</h2>

<p>Python modules are simply Python files, but they are not the only way we can bundle up our code for reuse. Modules are not that easy to share. The primary way we share code is by wrapping our modules into packages. In this lesson, we‚Äôll learn what it takes to create a Python package.</p>

<h3 id="documentation-4">Documentation</h3>

<ul>
  <li><a href="https://docs.python.org/3/tutorial/modules.html#packages">Python Packages Documentation</a>
-<a href="https://www.python.org/dev/peps/pep-0420/#specification">Implicit Namespace Packages</a></li>
</ul>

<h3 id="what-is-a-package-in-python">What Is a Package in Python?</h3>

<p>A package is a namespace that allows us to group modules together. We create a package in Python by creating a directory to hold our modules and adding a special file named <code class="language-plaintext highlighter-rouge">__init__.py</code>. To show how a package can allow us to organize our code even more, let‚Äôs create a helpers directory within using_modules. Let‚Äôs create an empty <code class="language-plaintext highlighter-rouge">__init__.py</code> file within that directory.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ mkdir ~/using_modules/helpers
$ touch ~/using_modules/helpers/__init__.py
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">__init__.py</code> doesn‚Äôt need to have anything in it, though we can and will use it later. Next, let‚Äôs move our <code class="language-plaintext highlighter-rouge">helpers.py</code> file into the <code class="language-plaintext highlighter-rouge">helpers</code> directory and change its name to <code class="language-plaintext highlighter-rouge">strings.py</code> since this file holds helper functions completely focused on working with strings. Our <code class="language-plaintext highlighter-rouge">extras.py</code> module actually doesn‚Äôt do anything besides defining variables, so let‚Äôs move it into <code class="language-plaintext highlighter-rouge">helpers</code> as <code class="language-plaintext highlighter-rouge">helpers/variables.py</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd ~/using_modules
$ mv helpers.py helpers/strings.py
$ mv extras.py helpers/variables.py
</code></pre></div></div>

<p>We now have a package that contains two modules, but we also broke main.py. Let‚Äôs change main.py to use our package, instead of the modules that we had before.</p>

<p><code class="language-plaintext highlighter-rouge">~/using_modules/main.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from helpers.strings import extract_lower, extract_upper
from helpers import variables
import helpers

print(f"Lowercase letters: {extract_lower(variables.name)}")
print(f"Uppercase letters: {extract_upper(variables.name)}")
print(f"From helpers: {helpers.strings.extract_lower(variables.name)}")
</code></pre></div></div>

<p>The things to note here are that we can access the modules within our packages by importing them directly like with <code class="language-plaintext highlighter-rouge">variables</code> and by chaining them off of the package name to import entities directly from the child module. Just like we can with a module, we‚Äôre able to import the package directly.</p>

<p>Running <code class="language-plaintext highlighter-rouge">main.py</code> again we should see:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3.7 main.py
Lowercase letters: ['e', 'i', 't', 'h', 'h', 'o', 'm', 'p', 's', 'o', 'n']
Uppercase letters: ['K', 'T']
From helpers: ['e', 'i', 't', 'h', 'h', 'o', 'm', 'p', 's', 'o', 'n']
</code></pre></div></div>

<h3 id="what-does-initpy-do">What Does <strong>init</strong>.py Do?</h3>

<p>The mysterious <code class="language-plaintext highlighter-rouge">__init__.py</code> file is used to set up the initialization code for a package, but what does this mean? This means that when the first subpackage or module within the parent package is accessed, then the code within <code class="language-plaintext highlighter-rouge">__init__.py</code> gets executed. The primary other thing we can do with our <code class="language-plaintext highlighter-rouge">__init__.py</code> is define the <code class="language-plaintext highlighter-rouge">__all__</code> value for when we use <code class="language-plaintext highlighter-rouge">from &lt;package&gt; import *</code>. This doesn‚Äôt immediately make sense because our <code class="language-plaintext highlighter-rouge">__init__.py</code> doesn‚Äôt define anything right now, but we can import parts from our submodules and then make those immediately available if someone imports our package. Let‚Äôs modify <code class="language-plaintext highlighter-rouge">helpers/__init__.py</code> to do just that.</p>

<p><code class="language-plaintext highlighter-rouge">~/using_modules/helpers/__init__.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>__all__ = ['extract_upper']

from .strings import *
</code></pre></div></div>

<p>The syntax of <code class="language-plaintext highlighter-rouge">.strings</code> allows us to specify that we want to load the strings module within our package, regardless of what our package is named. This is just a way to be a little more explicit. Let‚Äôs change our <code class="language-plaintext highlighter-rouge">main.py</code> to use this.</p>

<p><code class="language-plaintext highlighter-rouge">~/using_modules/main.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from helpers.strings import extract_lower
from helpers import variables
from helpers import *
import helpers

print(f"Lowercase letters (from strings): {extract_lower(variables.name)}")
print(f"Uppercase letters (from package): {extract_upper(variables.name)}")
print(f"Off of helpers: {helpers.strings.extract_lower(variables.name)}")
</code></pre></div></div>

<p>Once again, let‚Äôs run our script to see that this code works.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3.7 main.py
Lowercase letters (from strings): ['e', 'i', 't', 'h', 'h', 'o', 'm', 'p', 's', 'o', 'n']
Uppercase letters (from package): ['K', 'T']
Off of helpers: ['e', 'i', 't', 'h', 'h', 'o', 'm', 'p', 's', 'o', 'n']
</code></pre></div></div>

<h3 id="implicit-namespace-packages">Implicit Namespace Packages</h3>

<p>While the PCAP syllabus doesn‚Äôt actually mention implicit namespace packages, it is worth noting that they exist. As of Python 3.3, if we‚Äôre creating a package that doesn‚Äôt need to do anything with the <code class="language-plaintext highlighter-rouge">__init__.py</code>, then we can skip creating the <code class="language-plaintext highlighter-rouge">__init__.py</code> entirely and our package will work just fine.</p>

<h2 id="437-distributing-and-installing-packages">43.7. Distributing and Installing Packages</h2>

<p>Packages are invaluable when working in Python because the community has published a plethora of useful packages that can prevent us from needing to write that code ourselves. Additionally, we can share our own code with others by setting up our packages for distribution.</p>

<h3 id="documentation-5">Documentation</h3>

<p>-<a href="https://packaging.python.org/guides/distributing-packages-using-setuptools/">Distributing Packages and Setuptools</a></p>
<ul>
  <li><a href="https://pypi.org/">The Python Package Index</a></li>
  <li><a href="https://pip.pypa.io/en/stable/quickstart/">pip</a></li>
  <li><a href="https://pypi.org/project/requests/">requests PyPi Page</a></li>
</ul>

<h3 id="installing-packages">Installing Packages</h3>

<p>Before we look at how we can go about making our own packages installable, let‚Äôs cover installing a package from someone else. The primary place we‚Äôll be installing packages from will be from the <a href="https://pypi.org/">‚ÄúPython Package Index‚Äù</a> or <a href="https://pypi.org/">‚ÄúPyPi‚Äù</a> for short.</p>

<p>To install packages, we‚Äôll use <a href="https://pip.pypa.io/en/stable/quickstart/">pip</a>. Let‚Äôs install one of the most popular Python packages, the <a href="https://pypi.org/project/requests/">requests</a> package.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ pip3.7 install requests
Collecting requests
  Downloading https://files.pythonhosted.org/packages/51/bd/23c926cd341ea6b7dd0b2a00aba99ae0f828be89d72b2190f27c11d4b7fb/requests-2.22.0-py2.py3-none-any.whl (57kB)
     |????????????????????????????????| 61kB 2.4MB/s
Collecting certifi&gt;=2017.4.17 (from requests)
  Downloading https://files.pythonhosted.org/packages/b9/63/df50cac98ea0d5b006c55a399c3bf1db9da7b5a24de7890bc9cfd5dd9e99/certifi-2019.11.28-py2.py3-none-any.whl (156kB)
     |????????????????????????????????| 163kB 8.0MB/s
Collecting idna&lt;2.9,&gt;=2.5 (from requests)
  Downloading https://files.pythonhosted.org/packages/14/2c/cd551d81dbe15200be1cf41cd03869a46fe7226e7450af7a6545bfc474c9/idna-2.8-py2.py3-none-any.whl (58kB)
     |????????????????????????????????| 61kB 10.8MB/s
Collecting urllib3!=1.25.0,!=1.25.1,&lt;1.26,&gt;=1.21.1 (from requests)
  Downloading https://files.pythonhosted.org/packages/e8/74/6e4f91745020f967d09332bb2b8b9b10090957334692eb88ea4afe91b77f/urllib3-1.25.8-py2.py3-none-any.whl (125kB)
     |????????????????????????????????| 133kB 10.8MB/s
Collecting chardet&lt;3.1.0,&gt;=3.0.2 (from requests)
  Downloading https://files.pythonhosted.org/packages/bc/a9/01ffebfb562e4274b6487b4bb1ddec7ca55ec7510b22e4c51f14098443b8/chardet-3.0.4-py2.py3-none-any.whl (133kB)
     |????????????????????????????????| 143kB 12.8MB/s
Installing collected packages: certifi, idna, urllib3, chardet, requests
Successfully installed certifi-2019.11.28 chardet-3.0.4 idna-2.8 requests-2.22.0 urllib3-1.25.8
$
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">requests</code> package has some dependencies on other packages so <code class="language-plaintext highlighter-rouge">pip</code> will go ahead and download those dependencies. For the purposes of the PCAP exam, we just need to know how to install packages, but it is definitely worth viewing the other commands provided by <code class="language-plaintext highlighter-rouge">pip</code> by running <code class="language-plaintext highlighter-rouge">pip --help</code>.</p>

<h3 id="making-a-package-installable">Making a Package Installable</h3>

<p>To make a package installable, it needs to have a file in the root of the package called <code class="language-plaintext highlighter-rouge">setup.py</code>. The structure of installable packages can vary, but the presence of a <code class="language-plaintext highlighter-rouge">setup.py</code> is constant. Let‚Äôs make our <code class="language-plaintext highlighter-rouge">helpers</code> package installable by adding a <code class="language-plaintext highlighter-rouge">setup.py</code> and configuring it using the <a href="https://packaging.python.org/guides/distributing-packages-using-setuptools/#setup-args">setup function</a>. The ‚ÄúPython Packaging Authority‚Äù is the working group that maintains the core projects use for Python packaging, and they provide an example project. We‚Äôre going to take the <code class="language-plaintext highlighter-rouge">setup.py</code> from that project as a starting point and modify it for our purposes. To begin, we do need to change our <code class="language-plaintext highlighter-rouge">helpers</code> directory to be the container for our installable package (different than a ‚Äúpython package‚Äù). Let‚Äôs move things around before creating our <code class="language-plaintext highlighter-rouge">setup.py</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd ~/using_modules
$ mkdir -p helpers/src/helpers
$ mv helpers/*.py helpers/src/helpers/
</code></pre></div></div>

<p>Using <code class="language-plaintext highlighter-rouge">tree</code> on our directory structure for <code class="language-plaintext highlighter-rouge">helpers</code> will provide us a better way to view our directories. Note that you may have to install tree using <code class="language-plaintext highlighter-rouge">sudo yum install tree</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ tree helpers
helpers/
     |---&gt; src
           |---&gt; helpers
                |---&gt; __init__.py
                |---&gt; strings.py
                |---&gt; variables.py

2 directories, 3 files
</code></pre></div></div>

<p>The outer <code class="language-plaintext highlighter-rouge">helpers</code> directory is there just to hold onto our code and isn‚Äôt actually a Python package. The inner <code class="language-plaintext highlighter-rouge">helpers</code> will provide the package that can be imported after the distribution of this code is installed. For our code to be installable, we still need a <code class="language-plaintext highlighter-rouge">setup.py</code> file, which will go in the outer <code class="language-plaintext highlighter-rouge">helpers</code> directory. Feel free to download it directly using the <code class="language-plaintext highlighter-rouge">curl</code> command or copy and paste the contents below.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd helpers/
$ curl -O https://raw.githubusercontent.com/pypa/sampleproject/master/setup.py
</code></pre></div></div>

<p>Here‚Äôs what it will look like:</p>

<p><code class="language-plaintext highlighter-rouge">~/using_modules/helpers/setup.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from setuptools import setup, find_packages
from os import path

here = path.abspath(path.dirname(__file__))

# Get the long description from the README file
with open(path.join(here, 'README.md'), encoding='utf-8') as f:
    long_description = f.read()

setup(
    name='helpers', # Required
    version='1.0.0', # Required
    description='Our custom collection of helper functions and variables.', # Optional
    # long_description=long_description, # Optional
    # long_description_content_type='text/markdown', # Optional (the README is markdown so we want to set this)
    # url='https://github.com/pypa/sampleproject', # Optional
    author='Keith Thompson',  # Optional
    author_email='keith@linuxacademy.com',  # Optional

    # Classifiers help users find your project by categorizing it.
    #
    # For a list of valid classifiers, see https://pypi.org/classifiers/
    classifiers=[  # Optional
        # How mature is this project? Common values are
        #   3 - Alpha
        #   4 - Beta
        #   5 - Production/Stable
        'Development Status :: 3 - Alpha',

        # Indicate who your project is intended for
        'Intended Audience :: Developers',
        'Topic :: Software Development :: Build Tools',

        # Pick your license as you wish
        'License :: OSI Approved :: MIT License',

        # Specify the Python versions you support here. In particular, ensure
        # that you indicate whether you support Python 2, Python 3 or both.
        # These classifiers are *not* checked by 'pip install'. See instead
        # 'python_requires' below.
        'Programming Language :: Python :: 3',
        'Programming Language :: Python :: 3.5',
        'Programming Language :: Python :: 3.6',
        'Programming Language :: Python :: 3.7',
        'Programming Language :: Python :: 3.8',
    ],
    keywords='helpers',  # Optional

    # When your source code is in a subdirectory under the project root, e.g.
    # `src/`, it is necessary to specify the `package_dir` argument.
    package_dir={'': 'src'},  # Optional

    # You can just specify package directories manually here if your project is
    # simple. Or you can use find_packages().
    #
    # Alternatively, if you just want to distribute a single Python file, use
    # the `py_modules` argument instead as follows, which will expect a file
    # called `my_module.py` to exist:
    #
    #   py_modules=["my_module"],
    #
    packages=find_packages(where='src'),  # Required
    # Specify which Python versions you support. In contrast to the
    # 'Programming Language' classifiers above, 'pip install' will check this
    # and refuse to install the project if the version does not match. If you
    # do not support Python 2, you can simplify this to '&gt;=3.5' or similar, see
    # https://packaging.python.org/guides/distributing-packages-using-setuptools/#python-requires
    python_requires='!=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*, &lt;4',

    # This field lists other packages that your project depends on to run.
    # Any package you put here will be installed by pip when your project is
    # installed, so they must be valid existing projects.
    #
    # For an analysis of "install_requires" vs pip's requirements files see:
    # https://packaging.python.org/en/latest/requirements.html
    # install_requires=['peppercorn'],  # Optional

    # List additional groups of dependencies here (e.g. development
    # dependencies). Users will be able to install these using the "extras"
    # syntax, for example:
    #
    #   $ pip install sampleproject[dev]
    #
    # Similar to `install_requires` above, these must be valid existing
    # projects.
    # extras_require={  # Optional
    #     'dev': ['check-manifest'],
    #     'test': ['coverage'],
    # },

    # If there are data files included in your packages that need to be
    # installed, specify them here.
    #
    # If using Python 2.6 or earlier, then these have to be included in
    # MANIFEST.in as well.
    # package_data={  # Optional
    #     'sample': ['package_data.dat'],
    # },

    # Although 'package_data' is the preferred approach, in some case you may
    # need to place data files outside of your packages. See:
    # http://docs.python.org/3.4/distutils/setupscript.html#installing-additional-files
    #
    # In this case, 'data_file' will be installed into '&lt;sys.prefix&gt;/my_data'
    # data_files=[('my_data', ['data/data_file'])],  # Optional

    # To provide executable scripts, use entry points in preference to the
    # "scripts" keyword. Entry points provide cross-platform support and allow
    # `pip` to create the appropriate form of executable for the target
    # platform.
    #
    # For example, the following would provide a command called `sample` which
    # executes the function `main` from this package when invoked:
    # entry_points={  # Optional
    #     'console_scripts': [
    #         'sample=sample:main',
    #     ],
    # },

    # List additional URLs that are relevant to your project as a dict.
    #
    # This field corresponds to the "Project-URL" metadata fields:
    # https://packaging.python.org/specifications/core-metadata/#project-url-multiple-use
    #
    # Examples listed include a pattern for specifying where the package tracks
    # issues, where the source is hosted, where to say thanks to the package
    # maintainers, and where to support the project financially. The key is
    # what's used to render the link text on PyPI.
    # project_urls={  # Optional
    #     'Bug Reports': 'https://github.com/pypa/sampleproject/issues',
    #     'Funding': 'https://donate.pypi.org',
    #     'Say Thanks!': 'http://saythanks.io/to/example',
    #     'Source': 'https://github.com/pypa/sampleproject/',
    # },
)
</code></pre></div></div>

<p>We left a lot of comments in there because they are good to read and understand, but they‚Äôre for optional fields. Some of the important and potentially confusing lines to look at are the <code class="language-plaintext highlighter-rouge">package_dir</code> and <code class="language-plaintext highlighter-rouge">packages arguments</code>. We‚Äôve put our code into the src directory. We‚Äôve set these two arguments and used the <code class="language-plaintext highlighter-rouge">find_packages</code> function from <code class="language-plaintext highlighter-rouge">setuptools</code> to automatically find the packages that we‚Äôre providing when someone installs this.</p>

<h3 id="building-a-distribution">Building a Distribution</h3>

<p>Making code installable in Python means that we need to create a distribution. There are two primary types of distributions: eggs and wheels. Wheels are the modern way to create a distribution and they‚Äôre a single file that can be installed by pip. They will install any dependencies and place or unpack the source code into the <code class="language-plaintext highlighter-rouge">site-packages</code> directory for our Python installation. For us to build a wheel distribution, we need to install the <code class="language-plaintext highlighter-rouge">wheel</code> package and run a command using Python and our <code class="language-plaintext highlighter-rouge">setup.py</code> file. Let‚Äôs install wheel first.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ pip3.7 install --upgrade wheel
...
</code></pre></div></div>

<p>Setuptools provides us with multiple different subcommands if we process our <code class="language-plaintext highlighter-rouge">setup.py</code> through the Python interpreter. Let‚Äôs take a look at those commands.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3.7 setup.py --help
Traceback (most recent call last):
  File "setup.py", line 7, in &lt;module&gt;
    with open(path.join(here, 'README.md'), encoding='utf-8') as f:
FileNotFoundError: [Errno 2] No such file or directory: '/home/cloud_user/using_modules/helpers/README.md'
</code></pre></div></div>

<p>Our <code class="language-plaintext highlighter-rouge">setup.py</code> specifies that we‚Äôll provide documentation in a <code class="language-plaintext highlighter-rouge">README.md</code> file, but that file doesn‚Äôt exist, so we can‚Äôt read it. We‚Äôll cover file IO later in the course, but for now, we just need to make sure that that file exists.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ touch README.md
</code></pre></div></div>

<p>Now, let‚Äôs try again.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3.7 setup.py --help
Common commands: (see '--help-commands' for more)

  setup.py build      will build the package underneath 'build/'
  setup.py install    will install the package

Global options:
  --verbose (-v)      run verbosely (default)
  --quiet (-q)        run quietly (turns verbosity off)
  --dry-run (-n)      don't actually do anything
  --help (-h)         show detailed help message
  --no-user-cfg       ignore pydistutils.cfg in your home directory
  --command-packages  list of packages that provide distutils commands

Information display options (just display information, ignore any commands)
  --help-commands     list all available commands
  --name              print package name
  --version (-V)      print package version
  --fullname          print &lt;package name&gt;-&lt;version&gt;
  --author            print the author's name
  --author-email      print the author's email address
  --maintainer        print the maintainer's name
  --maintainer-email  print the maintainer's email address
  --contact           print the maintainer's name if known, else the author's
  --contact-email     print the maintainer's email address if known, else the
                      author's
  --url               print the URL for this package
  --license           print the license of the package
  --licence           alias for --license
  --description       print the package description
  --long-description  print the long package description
  --platforms         print the list of platforms
  --classifiers       print the list of classifiers
  --keywords          print the list of keywords
  --provides          print the list of packages/modules provided
  --requires          print the list of packages/modules required
  --obsoletes         print the list of packages/modules made obsolete

usage: setup.py [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
   or: setup.py --help [cmd1 cmd2 ...]
   or: setup.py --help-commands
   or: setup.py cmd --help
</code></pre></div></div>

<p>This gives us a lot of output, but only the common commands are provided to us. Reading the first line of the output, we can see that the rest of the commands can be shown by using ‚Äìhelp-commands instead of <code class="language-plaintext highlighter-rouge">--help</code>. Let‚Äôs do that.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3.7 setup.py --help-commands
Standard commands:
  build             build everything needed to install
  build_py          "build" pure Python modules (copy to build directory)
  build_ext         build C/C++ extensions (compile/link to build directory)
  build_clib        build C/C++ libraries used by Python extensions
  build_scripts     "build" scripts (copy and fixup #! line)
  clean             clean up temporary files from 'build' command
  install           install everything from build directory
  install_lib       install all Python modules (extensions and pure Python)
  install_headers   install C/C++ header files
  install_scripts   install scripts (Python or otherwise)
  install_data      install data files
  sdist             create a source distribution (tarball, zip file, etc.)
  register          register the distribution with the Python package index
  bdist             create a built (binary) distribution
  bdist_dumb        create a "dumb" built distribution
  bdist_rpm         create an RPM distribution
  bdist_wininst     create an executable installer for MS Windows
  check             perform some checks on the package
  upload            upload binary package to PyPI

Extra commands:
  bdist_wheel       create a wheel distribution
  alias             define a shortcut to invoke one or more commands
  bdist_egg         create an "egg" distribution
  develop           install package in 'development mode'
  dist_info         create a .dist-info directory
  easy_install      Find/get/install Python packages
  egg_info          create a distribution's .egg-info directory
  install_egg_info  Install an .egg-info directory for the package
  rotate            delete older distributions, keeping N newest files
  saveopts          save supplied options to setup.cfg or other config file
  setopt            set an option in setup.cfg or another config file
  test              run unit tests after in-place build
  upload_docs       Upload documentation to PyPI

usage: setup.py [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
   or: setup.py --help [cmd1 cmd2 ...]
   or: setup.py --help-commands
   or: setup.py cmd --help
There are plenty of commands in here to play with, but the one that we care about is the extra command bdist_wheel. This will build a wheel distribution that will work perfectly with pip. Let's run that now.

$ python3.7 setup.py bdist_wheel
running bdist_wheel
running build
running build_py
creating build
creating build/lib
creating build/lib/helpers
copying src/helpers/__init__.py -&gt; build/lib/helpers
copying src/helpers/strings.py -&gt; build/lib/helpers
copying src/helpers/variables.py -&gt; build/lib/helpers
installing to build/bdist.linux-x86_64/wheel
running install
running install_lib
creating build/bdist.linux-x86_64
creating build/bdist.linux-x86_64/wheel
creating build/bdist.linux-x86_64/wheel/helpers
copying build/lib/helpers/__init__.py -&gt; build/bdist.linux-x86_64/wheel/helpers
copying build/lib/helpers/strings.py -&gt; build/bdist.linux-x86_64/wheel/helpers
copying build/lib/helpers/variables.py -&gt; build/bdist.linux-x86_64/wheel/helpers
running install_egg_info
running egg_info
writing src/helpers.egg-info/PKG-INFO
writing dependency_links to src/helpers.egg-info/dependency_links.txt
writing top-level names to src/helpers.egg-info/top_level.txt
reading manifest file 'src/helpers.egg-info/SOURCES.txt'
writing manifest file 'src/helpers.egg-info/SOURCES.txt'
Copying src/helpers.egg-info to build/bdist.linux-x86_64/wheel/helpers-1.0.0-py3.7.egg-info
running install_scripts
creating build/bdist.linux-x86_64/wheel/helpers-1.0.0.dist-info/WHEEL
creating 'dist/helpers-1.0.0-py3-none-any.whl' and adding 'build/bdist.linux-x86_64/wheel' to it
adding 'helpers/__init__.py'
adding 'helpers/strings.py'
adding 'helpers/variables.py'
adding 'helpers-1.0.0.dist-info/METADATA'
adding 'helpers-1.0.0.dist-info/WHEEL'
adding 'helpers-1.0.0.dist-info/top_level.txt'
adding 'helpers-1.0.0.dist-info/RECORD'
removing build/bdist.linux-x86_64/wheel
</code></pre></div></div>

<p>We now have a build and dist directory inside of the upper helpers directory. The artifact that we created will be within the dist directory and end with a .whl extension.</p>

<p>Going back to ~/using_modules, we‚Äôll actually run into issues if we try to run main.py right now because there is no helpers package local to the file anymore. Here‚Äôs what we‚Äôll see when we run that script:</p>

<p>$ cd ~/using_modules
$ python3.7 main.py
Traceback (most recent call last):
  File ‚Äúmain.py‚Äù, line 1, in <module>
    from helpers.strings import extract_lower
ModuleNotFoundError: No module named 'helpers.strings'
To get around this, we'll install our package using pip and the wheel we built.</module></p>

<p>$ pip3.7 install helpers/dist/helpers-1.0.0-py3-none-any.whl
Processing ./helpers/dist/helpers-1.0.0-py3-none-any.whl
Installing collected packages: helpers
Successfully installed helpers-1.0.0
When we run a script or load the REPL, we can load the helpers package and its internal modules.</p>

<p>$ python3.7 main.py
Lowercase letters (from strings): [‚Äòe‚Äô, ‚Äòi‚Äô, ‚Äòt‚Äô, ‚Äòh‚Äô, ‚Äòh‚Äô, ‚Äòo‚Äô, ‚Äòm‚Äô, ‚Äòp‚Äô, ‚Äòs‚Äô, ‚Äòo‚Äô, ‚Äòn‚Äô]
Uppercase letters (from package): [‚ÄòK‚Äô, ‚ÄòT‚Äô]
Off of helpers: [‚Äòe‚Äô, ‚Äòi‚Äô, ‚Äòt‚Äô, ‚Äòh‚Äô, ‚Äòh‚Äô, ‚Äòo‚Äô, ‚Äòm‚Äô, ‚Äòp‚Äô, ‚Äòs‚Äô, ‚Äòo‚Äô, ‚Äòn‚Äô]
Our package is installed and our script runs again without using a module local to the script. We‚Äôre not going to cover publishing a package to PyPi in this course, but the PyPA documentation also details how to do that.</p>

<h2 id="438-docstrings-doctests-and-shebangs">43.8. Docstrings, Doctests, and Shebangs</h2>

<p>[]:</p>

:ET