I"´L<p>vcbcv</p>

<h2 id="431-creating-and-using-python-modules">43.1. Creating and Using Python Modules</h2>

<p>To have truly reusable code, we need to access functions, variables, and objects that have already been written. Thus we need to have a way to share our code. This is where modules and packages are useful. In this lesson, we demonstrate how to create our first Python module and access its contents from a different Python program.</p>

<p>Documentation</p>
<ul>
  <li><a href="https://docs.python.org/3/tutorial/modules.html">Python Modules Documentation</a></li>
  <li><a href="https://docs.python.org/3/reference/simple_stmts.html#import">The import Statement</a></li>
</ul>

<h3 id="what-is-a-module">What Is a Module?</h3>

<p>Working with Python it‚Äôs very easy to define new functions and assign values to variables that we would like to use multiple times. It would be great if we could write these useful pieces of code once and then use them whenever we need them. Thankfully, we can do just that because of modules. In Python, a module is just a Python file. This means that we can use modules to divide our code into logical groupings by putting them into separate modules and then pulling those modules into our scripts or applications when we need them.</p>

<h3 id="creating-our-first-module">Creating Our First Module</h3>
<p>To demonstrate how to create and use modules, let‚Äôs create a new directory called <code class="language-plaintext highlighter-rouge">using_modules</code>. Within it, we‚Äôll define our first module by creating the <code class="language-plaintext highlighter-rouge">using_modules/helpers.py</code> file.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ mkdir ~/using_modules
$ cd ~/using_modules
$ touch helpers.py
</code></pre></div></div>

<p>Within <code class="language-plaintext highlighter-rouge">helpers.py</code>, we‚Äôre placing some functions that we think will be generally useful and likely to be used in other files. Let‚Äôs write a few functions that can manipulate strings. <code class="language-plaintext highlighter-rouge">~/using_modules/helpers.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def extract_upper(phrase):
    return list(filter(str.isupper, phrase))

def extract_lower(phrase):
    return list(filter(str.islower, phrase))
</code></pre></div></div>

<p>Now we have two functions defined and we‚Äôd like to use them in other scripts and modules.</p>

<h3 id="using-our-module-from-another-script">Using Our Module from Another Script</h3>

<p>For this section of the course, we‚Äôre going to be putting our example code into a script called main.py. Let‚Äôs create that script now and look at what we can do to pull in these functions so that we can use them.</p>

<p>The key to working with modules is the <a href="https://docs.python.org/3/reference/simple_stmts.html#import">import statement</a> . We‚Äôre going to dig deeper into all that we can do while importing modules in the next lesson. But for now, we‚Äôre going to leverage the fact that we can import modules in the same directory as our script by referencing them by their file name minus the extension. In our case, this will <code class="language-plaintext highlighter-rouge">be helpers</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/using_modules/main.py
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import helpers
</code></pre></div></div>

<p>Before we use our functions, let‚Äôs make sure that this file is valid by running it.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3.7 main.py
$
No output is a good sign. To utilize the functions defined in our module, we'll add a period to the end of our module name (i.e. the file name) and then type the name of our function to call it as we otherwise would.

~/using_modules/main.py

import helpers

name = "Keith Thompson"
print(f"Lowercase letters: {helpers.extract_lower(name)}")
print(f"Uppercase letters: {helpers.extract_upper(name)}")
Let's run this and verify it works as expected.

$ python3.7 main.py
Lowercase letters: ['e', 'i', 't', 'h', 'h', 'o', 'm', 'p', 's', 'o', 'n']
Uppercase letters: ['K', 'T']

</code></pre></div></div>

<p>Perfect! Now we know the simplest way to define and use modules. In the next lesson, we‚Äôll dig deeper into the various ways and places that we can import modules.</p>

<h2 id="432-importing-modules">43.2. Importing Modules</h2>

<p>Python provides a few different ways to import modules and packages. In this lesson, we‚Äôll take a look at how importing works and the various ways we can import definitions from a module.</p>

<h3 id="documentation">Documentation</h3>
<ul>
  <li><a href="https://docs.python.org/3/tutorial/modules.html">Python Modules Documentation</a></li>
  <li><a href="https://docs.python.org/3/reference/simple_stmts.html#import">The import Statement</a></li>
</ul>

<h2 id="the-standard-import-statement">The Standard import Statement</h2>

<p>When we learned how to create a module, we also learned how to import the module as a singular entity into other Python files. To reiterate this, we use the following format to import an entire module under its namespace.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import my_module_name
</code></pre></div></div>

<p>By doing this, we‚Äôre able to access anything exposed by the module by chaining off of the module‚Äôs name. Occasionally, we might have a naming conflict when importing a module. In those cases, we can also use the keyword <code class="language-plaintext highlighter-rouge">as</code> in the <code class="language-plaintext highlighter-rouge">import</code> statement to change the identifier that we use to represent the module. Let‚Äôs change our <code class="language-plaintext highlighter-rouge">using_modules/main.py</code> so that the <code class="language-plaintext highlighter-rouge">helpers</code> module is accessed using the h name.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/using_modules/helpers.py
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import helpers as h

name = "Keith Thompson"
print(f"Lowercase letters: {h.extract_lower(name)}")
print(f"Uppercase letters: {h.extract_upper(name)}")
</code></pre></div></div>

<p>The name of <code class="language-plaintext highlighter-rouge">h</code> isn‚Äôt great, but it does demonstrate that we can change the name of modules when we import them. If we run this script, we will see there‚Äôs no difference in the output.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3.7 main.py
Lowercase letters: ['e', 'i', 't', 'h', 'h', 'o', 'm', 'p', 's', 'o', 'n']
Uppercase letters: ['K', 'T']
</code></pre></div></div>

<h3 id="importing-from">Importing from</h3>

<p>More often than not, we don‚Äôt need to use everything provided by a module. In these cases, we can leverage the <code class="language-plaintext highlighter-rouge">from</code> version of an <code class="language-plaintext highlighter-rouge">import</code> statement to import only the definitions we need from the module, and then we can access them directly. To demonstrate how to do this for multiple functions, let‚Äôs directly import the functions from our <code class="language-plaintext highlighter-rouge">helpers</code> module. The <code class="language-plaintext highlighter-rouge">from</code> statement works like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from &lt;MODULE_NAME&gt; import &lt;definition&gt;, &lt;definition&gt;, &lt;etc.&gt;
</code></pre></div></div>

<p>Here‚Äôs what it looks like in <code class="language-plaintext highlighter-rouge">main.py</code>:</p>

<p><code class="language-plaintext highlighter-rouge">~/using_modules/main.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from helpers import extract_lower, extract_upper

name = "Keith Thompson"
print(f"Lowercase letters: {extract_lower(name)}")
print(f"Uppercase letters: {extract_upper(name)}")
</code></pre></div></div>

<p>It‚Äôs worth noting that now we don‚Äôt have access to the <code class="language-plaintext highlighter-rouge">helpers</code> name in our code at all. If we change our <code class="language-plaintext highlighter-rouge">extract_upper</code> line to be chained off of <code class="language-plaintext highlighter-rouge">helpers</code> name it will cause an error.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3.7 main.py
Lowercase letters: ['e', 'i', 't', 'h', 'h', 'o', 'm', 'p', 's', 'o', 'n']
Traceback (most recent call last):
  File "using_modules/main.py", line 5, in &lt;module&gt;
    print(f"Uppercase letters: {helpers.extract_upper(name)}")
NameError: name 'helpers' is not defined
</code></pre></div></div>

<p>Lastly, we can also combine the <code class="language-plaintext highlighter-rouge">as</code> keyword with each definition that we‚Äôre importing to explicitly rename that definition.</p>

<p><code class="language-plaintext highlighter-rouge">~/using_modules/main.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from helpers import extract_lower as e_low, extract_upper

name = "Keith Thompson"
print(f"Lowercase letters: {e_low(name)}")
print(f"Uppercase letters: {extract_upper(name)}")
</code></pre></div></div>

<h3 id="importing-everything-from-a-module">Importing Everything from a Module</h3>

<p>The final way we can import definitions from a module is to import all of them at once by using <code class="language-plaintext highlighter-rouge">*</code>. This is generally not the recommended way of importing things, but sometimes a module provides a lot of functions that we‚Äôll be using, and we don‚Äôt want to explicitly import them one at a time.</p>

<p>Let‚Äôs utilize the <code class="language-plaintext highlighter-rouge">*</code> to import our two functions from the <code class="language-plaintext highlighter-rouge">helpers</code> module without explicitly naming them.</p>

<p><code class="language-plaintext highlighter-rouge">~/using_modules/main.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from helpers import *

name = "Keith Thompson"
print(f"Lowercase letters: {extract_lower(name)}")
print(f"Uppercase letters: {extract_upper(name)}")
</code></pre></div></div>

<p>Once again, if we run this, it will work just as it did before.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3.7 main.py
Lowercase letters: ['e', 'i', 't', 'h', 'h', 'o', 'm', 'p', 's', 'o', 'n']
Uppercase letters: ['K', 'T']
</code></pre></div></div>

<h2 id="433-executing-modules-as-scripts">43.3. Executing Modules as Scripts</h2>

<p>Python modules are just files, but sometimes we want them to behave slightly differently if they‚Äôre being run directly. In this lesson, we‚Äôll learn about how modules are interpreted when imported and also how to only run code when a module is run directly by using the <strong>name</strong> variable.</p>

<h3 id="documentation-1">Documentation</h3>

<ul>
  <li><a href="https://docs.python.org/3/tutorial/modules.html">Python Modules Documentation</a></li>
  <li><a href="https://docs.python.org/3/reference/simple_stmts.html#import">The import Statement</a></li>
  <li><a href="https://docs.python.org/3/library/__main__.html">The <strong>name</strong> Variable</a></li>
</ul>

<h3 id="expressions-in-a-module">Expressions in a Module</h3>

<p>Since modules are just Python files, they can contain expressions and the file will be interpreted from top to bottom. So a few good questions to ask ourselves are:</p>

<ol>
  <li>When is a module interpreted?</li>
  <li>Can a module be interpreted twice?</li>
</ol>

<p>To test this, let‚Äôs create another module that imports our <code class="language-plaintext highlighter-rouge">helpers</code> module and also import that new module into our <code class="language-plaintext highlighter-rouge">main.py</code>. We‚Äôll call this module <code class="language-plaintext highlighter-rouge">extras.py</code>.</p>

<p><code class="language-plaintext highlighter-rouge">~/using_modules/extras.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>print("Importing 'helpers' in 'extras'")
import helpers

name = "Keith Thompson"
</code></pre></div></div>

<p>In <code class="language-plaintext highlighter-rouge">main.py</code>, let‚Äôs import extras.</p>

<p><code class="language-plaintext highlighter-rouge">~/using_modules/main.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>print("We're importing 'helpers' from 'main'")
from helpers import *

print("We're importing 'extras' from 'main'")
import extras

print(f"Lowercase letters: {extract_lower(extras.name)}")
print(f"Uppercase letters: {extract_upper(extras.name)}")
</code></pre></div></div>

<p>Finally, in <code class="language-plaintext highlighter-rouge">helpers.py</code> we‚Äôll add <code class="language-plaintext highlighter-rouge">print</code>, so that we can see when it is run and how many times it is run.</p>

<p><code class="language-plaintext highlighter-rouge">~/using_modules/helpers.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def extract_upper(phrase):
    return list(filter(str.isupper, phrase))

def extract_lower(phrase):
    return list(filter(str.islower, phrase))

print("HELLO FROM HELPERS")
</code></pre></div></div>

<p>We now have enough print lines to helps us really see how <code class="language-plaintext highlighter-rouge">main.py</code> is processed and when our modules are interpreted. When we run it, this is what we see:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3.7 main.py

We're importing 'helpers' from 'main'
HELLO FROM HELPERS
We're importing 'extras' from 'main'
We're import 'helpers' from 'extras'
Lowercase letters: ['e', 'i', 't', 'h', 'h', 'o', 'm', 'p', 's', 'o', 'n']
Uppercase letters: ['K', 'T']
</code></pre></div></div>

<p>As we can see, the code within the <code class="language-plaintext highlighter-rouge">helpers</code> module was only interpreted the first time that it was imported. So even though it was imported into two different modules, it was only ever run one time.</p>

<h3 id="running-a-module-directly">Running a Module Directly</h3>

<p>Ideally, we don‚Äôt want to run this <code class="language-plaintext highlighter-rouge">print</code> line when our module is imported, but sometimes we do want a module to execute something if it is run directly. To handle this, we can access the <code class="language-plaintext highlighter-rouge">__name__</code> variable. The <code class="language-plaintext highlighter-rouge">__name__</code> variable is set in each module and can be used to determine if the module is being run directly as opposed to being imported. Let‚Äôs change the various print lines from our previous lesson to help us understand the values set to <code class="language-plaintext highlighter-rouge">__name__</code> in each of our scripts.</p>

<p><code class="language-plaintext highlighter-rouge">~/using_modules/main.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from helpers import *
import extras

print(f"__name__ in main.py: {__name__}")

print(f"Lowercase letters: {extract_lower(extras.name)}")
print(f"Uppercase letters: {extract_upper(extras.name)}")
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">~/using_modules/helpers.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def extract_upper(phrase):
    return list(filter(str.isupper, phrase))

def extract_lower(phrase):
    return list(filter(str.islower, phrase))

print(f"__name__ in helpers.py: {__name__}")
print("HELLO FROM HELPERS")

¬¥~/using_modules/extras.py¬¥

</code></pre></div></div>
<p>import helpers</p>

<p>print(f‚Äù<strong>name</strong> in extras.py: {<strong>name</strong>}‚Äù)</p>

<p>name = ‚ÄúKeith Thompson‚Äù
Here‚Äôs what we see when we run main.py:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
`$ python3.7 main.py`

</code></pre></div></div>
<p><strong>name</strong> in helpers.py: helpers
HELLO FROM HELPERS
<strong>name</strong> in extras.py: extras
<strong>name</strong> in main.py: <strong>main</strong>
Lowercase letters: [‚Äòe‚Äô, ‚Äòi‚Äô, ‚Äòt‚Äô, ‚Äòh‚Äô, ‚Äòh‚Äô, ‚Äòo‚Äô, ‚Äòm‚Äô, ‚Äòp‚Äô, ‚Äòs‚Äô, ‚Äòo‚Äô, ‚Äòn‚Äô]
Uppercase letters: [‚ÄòK‚Äô, ‚ÄòT‚Äô]</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
All of the modules that we imported have __name__ set to the actual module name, but main.py is set to __main__ because it is running in the main context. A common pattern is to add a condition like this if we want to add functionality to a module only if it is running in the main context:

if __name__ == "__main__":
    print("Something only when running in main scope")
To demonstrate this, let's remove all of these debugging lines, but move "HELLO FROM HELPERS" into this conditional in helpers.py.

(We're only showing the change to helpers.py, but we removed all of the '__name__ in ...' output)

`~/using_modules/helpers.py`


</code></pre></div></div>
<p>def extract_upper(phrase):
    return list(filter(str.isupper, phrase))</p>

<p>def extract_lower(phrase):
    return list(filter(str.islower, phrase))</p>

<p>if <strong>name</strong> == ‚Äú<strong>main</strong>‚Äù:
    print(‚ÄúHELLO FROM HELPERS‚Äù)</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>If we now run main.py we should see the following:

</code></pre></div></div>
<p>$ python3.7 main.py
Lowercase letters: [‚Äòe‚Äô, ‚Äòi‚Äô, ‚Äòt‚Äô, ‚Äòh‚Äô, ‚Äòh‚Äô, ‚Äòo‚Äô, ‚Äòm‚Äô, ‚Äòp‚Äô, ‚Äòs‚Äô, ‚Äòo‚Äô, ‚Äòn‚Äô]
Uppercase letters: [‚ÄòK‚Äô, ‚ÄòT‚Äô]</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
If we run helpers.py directly, we should see the print line being run.

</code></pre></div></div>
<p>$ python3.7 helpers.py
HELLO FROM HELPERS
```</p>

<h2 id="434-hiding-module-entities">43.4. Hiding Module Entities</h2>

<h2 id="435-the-module-search-path">43.5. The Module Search Path</h2>

<h2 id="436-creating-and-using-python-packages">43.6. Creating and Using Python Packages</h2>

<h2 id="437-distributing-and-installing-packages">43.7. Distributing and Installing Packages</h2>

<h2 id="438-docstrings-doctests-and-shebangs">43.8. Docstrings, Doctests, and Shebangs</h2>

<p>[]:</p>

:ET